<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
<title>LowRes NX Manual</title>
<style>
body {
	font-family: sans-serif;
}
td, th {
    padding-right: 1em;
    vertical-align: top;
}
th {
    text-align: left;
}
a {
    text-decoration: none;
}
ul {
    padding-left: 25px;
}
li {
    margin-bottom: 0.5em;
}
h1 {
	border-top: 6px solid black;
	padding-top: 6px;
	text-transform: uppercase;
	clear: both;
}
h2 {
	border-top: 2px solid black;
	padding: 4px 0;
	clear: both;
}
p + h1, ul + h1, pre + h1, table + h1, div + h1 {
	margin-top: 3em;
}
p + h2, ul + h2, pre + h2, table + h2, div + h2 {
	margin-top: 2em;
}
p + h3, ul + h3, pre + h3, table + h3, div + h3 {
	margin-top: 1.5em;
}
.container {
	margin-left: auto;
	margin-right: auto;
	max-width: 640px;
	padding-left: 15px;
	padding-right: 15px;
}
.info-mobile, .info-desktop {
	padding-left: 38px;
	margin: 1em 0;
	min-height: 30px;
	background-repeat: no-repeat;
	background-position: top left;
}
.info-mobile {
	background-image: url(manual-images/icon_mobile.png);
	background-image: -webkit-image-set(url(manual-images/icon_mobile.png) 1x, url(manual-images/icon_mobile@2x.png) 2x);
}
.info-desktop {
	background-image: url(manual-images/icon_desktop.png);
	background-image: -webkit-image-set(url(manual-images/icon_desktop.png) 1x, url(manual-images/icon_desktop@2x.png) 2x);
}
.illustration {
	float: right;
}
.illustration-nofloat {
	display: block;
	float: none;
}
@media (max-width: 480px) {
	.illustration, .illustration-nofloat {
		display: block;
		float: none;
		margin-left: auto;
		margin-right: auto;
	}
}
@media (max-width: 400px) {
	.bigtable td {
		font-size: 0.7em;
	}
    .container {
        padding-left: 8px;
        padding-right: 8px;
    }
}
.nobr {
	white-space: nowrap;
	hyphens: none;
}

</style>
</head>

<body>
<div class="container">

<h1 id="Introduction">Introduction</h1>

<img class="illustration" src="manual-images/illustration_hello.png" srcset="manual-images/illustration_hello.png 1x, manual-images/illustration_hello@2x.png 2x"/>

<h3 id="Program-retro-games-in-BASIC">Program retro games in BASIC</h3>

<p>Make your own retro games on a virtual game console. Program in the classic BASIC language and create sprites, tile maps, sound and music with the included tools. As a beginner you will quickly understand how to create simple text games or show your first sprite on a tile map. As an experienced programmer you can discover the full potential of retro hardware tricks!</p>

<h3 id="Virtual-Game-Console">Virtual Game Console</h3>

<p>Imagine LowRes NX as a handheld game console with a d-pad, two action buttons and a little rubber keyboard below a slidable touchscreen. LowRes NX was inspired by real 8- and 16-bit systems and simulates chips for graphics, sound and I/O, which actually work like classic hardware. It supports hardware sprites as well as hardware parallax scrolling, and even offers vertical blank and raster interrupts to create authentic retro effects.</p>

<h3 id="Old-School-Programming">Old-School Programming</h3>

<p>The programming language of LowRes NX is based on second-generation, structured BASIC. It offers all the classic commands, but with labels, loops and subprograms instead of line numbers. Graphics and sound are supported by additional commands and you can even access the virtual hardware directly using PEEK and POKE. You have complete control over the program flow, there is no standard update function to implement.</p>

<h3 id="Creative-Tools">Creative Tools</h3>

<p>LowRes NX includes all the tools you need: The Character Designer for editing sprites, tiles and fonts, the Background Designer for tile maps and screen layouts, as well as the Sound Composer for music and sound effects. All of these are just normal BASIC programs. You can change and improve them or even create your own custom editors.</p>

<h3 id="Share-and-Play">Share and Play</h3>

<p>Send your games directly to other users or share them via the website. All programs are open source, so you can play them, learn from them and edit them. Do you prefer making just art or music? Share your creations as assets and let other programmers use them in their projects.</p>

<img class="illustration-nofloat" src="manual-images/illustration_open.png" srcset="manual-images/illustration_open.png 1x, manual-images/illustration_open@2x.png 2x"/>


<h2 id="Specifications">Specifications</h2>

<ul>
<li>Cartridge ROM: 32 KB for gfx, music, any binary data</li>
<li>Code: BASIC, max 16384 tokens</li>
<li>Screen: 160x128 pixels, 60 Hz</li>
<li>Backgrounds: Two layers, tile-based, scrollable</li>
<li>Sprites: 64, max 32x32 pixels</li>
<li>Colors: 8 dynamic 6-bit palettes with 4 colors each</li>
<li>Sound: 4 voices, saw/tri/pulse/noise, pulse width, volume, ADSR, LFO</li>
<li>Input: Two game controllers with d-pad and two buttons + pause</li>
<li>Optional input: Keyboard and touchscreen/mouse</li>
</ul>


<h2 id="Getting-Started">Getting Started</h2>

<img class="illustration" src="manual-images/illustration_playing.png" srcset="manual-images/illustration_playing.png 1x, manual-images/illustration_playing@2x.png 2x"/>

<p>Try some of the included programs to see how LowRes NX
can look like. Have a look at the action game <i>LowRes Galaxy 2</i>,
the text adventure <i>LowRes Adventure</i>, and the demo <i>Star Scroller</i>.</p>

<div class="info-mobile">
On the "My Programs" screen select a program to open the source code
editor. Then tap on the Play button to run it.
</div>

<div class="info-desktop">
Find the examples in the folder "programs".  Open the LowRes NX
application and drag and drop any .nx file into its window. You can
also select LowRes NX as default application for .nx files, so
programs can be started simply by double clicking them.
</div>

<p>Once you have played enough, you can create your first own program.</p>

<div class="info-mobile">
On the "My Programs" screen tap on the Plus button to create a new
program. Select it to open the source code editor.
</div>

<div class="info-desktop">
Use any text editor to create a new file.
On Windows make sure the text editor supports Mac/Linux line ends,
otherwise you may see everything in one line.
</div>

<p>Type these lines:</p>

<pre>
PRINT "WELCOME!"
PRINT "WHAT IS YOUR NAME?"
INPUT ">";N$
PRINT "HELLO ";N$;"!"
</pre>

<div class="info-desktop">
Save your program file with a useful name and the extension ".nx".
</div>

<p>Now run your program. This is a little example using the keyboard.
Let's try something with a gamepad. Create another new program and
type this:</p>

<pre>
GAMEPAD 1
X=76
Y=60
DO
 IF UP(0) THEN Y=Y-1
 IF DOWN(0) THEN Y=Y+1
 IF LEFT(0) THEN X=X-1
 IF RIGHT(0) THEN X=X+1
 SPRITE 0,X,Y,225
 WAIT VBL
LOOP
</pre>

<p>Run this program and you will see an "A" on the screen which you can
move around using the gamepad.</p>

<div class="info-mobile">
With the program still running, tap the menu button on the top right
and select "Capture Program Icon".
Now exit the program and return to the "My Programs" screen. There
you will see your program with a new image. Long tap the icon and
select "Rename..." to give it a better name.
</div>


<h1 id="Editing">Editing</h1>

<h2 id="Programs-And-Data">Programs and Data</h2>

<img class="illustration" src="manual-images/illustration_disk.png" srcset="manual-images/illustration_disk.png 1x, manual-images/illustration_disk@2x.png 2x"/>

<p>A program file contains a complete game or application, including all
its data, stored as simple text. The first part is the BASIC source code.
Please read the programming chapters for further explanation.</p>

<p>The second part are the cartridge ROM entries. These are up to 16
numbered data blocks, which can contain any kind of data, for
example graphics, level maps, music, etc. When a program is running,
all its ROM entries are accessable in the first 32 KB of the memory.</p>

<p>You can easily create and edit ROM entries by using tools.
Tools are normal NX programs, but they are specifically
made for editing data. They can access any NX file as a "virtual disk"
and use its ROM entries like files.</p>

<p>There are two ways of using tools:</p>

<ul>
<li>You can open tools directly like other NX programs. They will use
the "Disk.nx" file in the tool's folder for loading and saving their
data.</li>
<li>You can open any program you want to edit and select a tool from a
menu. This way the tool will access directly the data of the current
program.</li>
</ul>

<p>Let's try it. Open your program with the moving "A" (from the
"Getting Started" chapter) and select "Char Designer" from the Tools
menu.</p>

<div class="info-mobile">
Open your program, tap the Tools button and select the tool.
</div>

<div class="info-desktop">
Run your program and press the Escape key to enter the development
menu. Then press the Edit (ED) button and select the tool.
By default the tools menu is empty, so drag and drop the programs
"Char Designer", "BG Designer" and "Sound Designer" into the window.
</div>

<p>Draw something as character #1 (keep #0 empty), then tap on "Disk"
and save as file 2 ("Main Characters"). Now return to the source code editor and you will see some hexadecimal data below your program.
This is your image! To see it, change the line</p>
<pre>SPRITE 0,X,Y,225</pre>
<p>to</p>
<pre>SPRITE 0,X,Y,1</pre>
<p>and run your program. There it is!</p>

<div class="info-desktop">
Press Ctrl+R in the LowRes NX application to reload and run your
current program. The Run button in the developer menu does the same.
</div>

<p>Keep in mind that tools don't save automatically, so never forget
to save before you exit them.</p>


<h2 id="Standard-ROM-Entries">Standard ROM Entries</h2>

<p>For an easy start you should use the ROM entry numbers of the
following table. Their data is made ready for use automatically.
</p>
<table>
<tr><td>#0</td><td>Keep empty for default font</td></tr>
<tr><td>#1</td><td>Color palettes</td></tr>
<tr><td>#2</td><td>Characters (sprites, tiles)</td></tr>
<tr><td>#3</td><td>Background (tile map)</td></tr>
<tr><td>#15</td><td>Sounds and music</td></tr>
</table>

<p>If cartridge ROM entry 0 is not used by a program, the compiler adds
character data for the default font. It occupies the characters
192-255 and is automatically copied to video RAM on program start.
If you want to use the default font, make sure to keep ROM entry 0
unused.</p>


<h2 id="Character-Designer">Character Designer</h2>

<img class="illustration" src="manual-images/illustration_painting.png"  srcset="manual-images/illustration_painting.png 1x, manual-images/illustration_painting@2x.png 2x"/>

<p>Use the Character Designer to draw your sprites and background
tiles. It shows images in grayscale only, black is used as
transparent background. Color palettes can be created later in the
Background Designer.</p>
<p>The Character Designer loads file number 2 on startup, but
keep in mind that it does not save automatically.</p>


<h3 id="CD-Main-Screen">Main Screen</h3>

<p>At the bottom part you see the 256 characters split into four pages.
There you can select the current one for editing. Keep the last page
empty, if you want to use the default font. Also character #0 should
be empty for a clean background.</p>
<p>The top left square is for drawing the current character using the
selected color.</p>

<table>
<tr><td>FLIP</td><td>Flip the current character horizontally or vertically.</td></tr>
<tr><td>SPIN</td><td>Rotate the current character.</td></tr>
<tr><td>CLR</td><td>Clear the current character with the selected
color.</td></tr>
<tr><td>CUT</td><td>Copy and clear the current character.</td></tr>
<tr><td>COP</td><td>Copy the current character.</td></tr>
<tr><td>PAS</td><td>Paste the copied character.</td></tr>
<tr><td>DISK</td><td>Go to the disk menu.</td></tr>
<tr><td>16*16</td><td>Go to the 16x16-pixel edit screen.</td></tr>
<tr><td>FON</td><td>Copy the standard font to the current page.</td></tr>
<tr><td>NEW</td><td>Clear all characters.</td></tr>
</table>

<h3 id="CD-Disk-Menu">Disk Menu</h3>

<p>The list shows all 16 files of the current virtual disk, or in
other words the ROM entries of the program you are editing. Select one
(usually number 2) and tap on Load or Save.</p>


<h2 id="Background-Designer">Background Designer</h2>

<img class="illustration" src="manual-images/illustration_building.png" srcset="manual-images/illustration_building.png 1x, manual-images/illustration_building@2x.png 2x"/>

<p>The Background Designer allows you to create tile-based screens or
level maps of different sizes. Additionally it's for creating color palettes. On the bottom right there are three tabs for the different
sections of the program: The map editor, the selection screen and
the disk menu.</p>
<p>The Background Designer loads the main characters (file 1),
palettes (file 2) and background (file 3) on startup, but keep in
mind that it doesn't save automatically.</p>


<h3 id="BD-Selection-Screen">Selection Screen</h3>

<p>On the top there is the character selector. Drag to select several
characters at once. In the box at the left you select the current
color palette. On the right you can edit each color of the current
palette using the RGB sliders. The first color is usually transparent
and unused, except the first color of palette 0, which is used as the
screen backdrop color.
</p>


<h3 id="BD-Map-Editor">Map Editor</h3>

<p>Here you draw your background using the character and color palette
currently selected on the selection screen. On the bottom appear some
tools:</p>

<table>
<tr><td>Pan</td><td>Drag the visible map area.</td></tr>
<tr><td>Stamp</td><td>Draw with the selected character and color
palette, using the selected flip and priority attributes.</td></tr>
<tr><td>Paint</td><td>Change the color palette only.</td></tr>
<tr><td>Priority</td><td>Change the priority only. Cells with priority
1 are shown in green, all others in red.</td></tr>
<tr><td>FLIP</td><td>Toggles the X/Y flip attributes.</td></tr>
<tr><td>PRI</td><td>Toggles the priority attribute.</td></tr>
</table>

<p>You can use the arrow keys to scroll the map when running LowRes
NX on a computer.</p>


<h3 id="BD-Disk-Menu">Disk Menu</h3>

<p>From here you load and save characters, color palettes and the
background separately. There is no option to save everything at once.
For the background there are two additional options:</p>

<table>
<tr><td>NEW</td><td>Clear the complete background (keeping its size).
</td></tr>
<tr><td>SIZE</td><td>Go to the size menu, where you can choose
the width and height of the background (in cells), as well as the cell size (8x8 or 16x16 pixels).</td></tr>
</table>


<h2 id="Sound-Composer">Sound Composer</h2>

<img class="illustration" src="manual-images/illustration_music.png" srcset="manual-images/illustration_music.png 1x, manual-images/illustration_music@2x.png 2x"/>

<p>The Sound Composer serves to create sound presets, sequences
("tracks") and complete songs.</p>
<p>It loads the main sound data (file 15) on startup, but keep in mind
that it doesn't save automatically. A sound file includes all sound
and music data.</p>


<h3 id="SC-Structure">Structure</h3>

<p>- 16 Sounds</p>
<p>A sound is a preset with all available sound parameters (waveform,
envelope, LFO, etc.). It can be used directly with the PLAY command in
your program or as an instrument in a track/song.</p>

<p>- 64 Tracks</p>
<p>A track is a sequence of 32 steps for a single voice, where each
step can play a note or modify the sound. It can be used in your
program for complex sound effects and short melodies (e.g. "level up")
with the TRACK command. Tracks are also used to create songs.</p>

<p>- 64 Patterns</p>
<p>A pattern is a block of music, which defines which track should be
played on each of the four voices. Patterns will be played one after
another, except for the following cases: If the next pattern is empty,
the song is stopped. When the current pattern finishes and has a "loop
end" flag, the player jumps back to the previous pattern with a "loop
start" flag. When a pattern finishes and has a "stop" flag, the player
stops.<br/>
If you want to create music for a game and you plan to use
additional sound effects, you should leave at least one voice empty.</p>

- Songs
<p>The 64 patterns can be used for one long song or several shorter
ones. By using the "loop" and "stop" flags songs can be separated. To
play one specific song, just start at its first pattern. To play a
song in your program use the MUSIC command.</p>


<h3 id="SC-Editors">Editors</h3>

<p>The Sound Composer has three tabs in the top right corner for the
different sections: The pattern editor, the track editor and the sound
editor. This is a "Tracker"-style program, which means the timeline
goes from top to bottom, not from left to right. So the steps in a
track are also called rows. Most values in the range from 0 to 15 are
shown in hexadecimal format (0-F).</p>
<p>There is some keyboard support when running LowRes NX on a
computer: The arrow keys move the cursor and the key rows simulate a
musical keyboard with two octaves to enter notes. The return key
enters a note stop, backspace deletes the current note and space
toggles between play (pattern/track) and stop.
</p>

<h3 id="SC-The-Pattern-Editor">The Pattern Editor</h3>
<p>Here you can select a pattern, choose its tracks for all voices and
edit directly the notes of each selected track. There is also a toggle
button for the "loop" and "stop" flags for the current pattern. If you
set notes in a voice without track, it selects automatically a free
track. Use the star symbol from the musical keyboard, if you want to
stop/release a note in a track.</p>

<h3 id="SC-The-Track-Editor">The Track Editor</h3>
<p>Here you can select and edit a single track with additional
parameters:</p>
<table>
<tr><td>S</td><td>Sound</td></tr>
<tr><td>V</td><td>Volume</td></tr>
<tr><td>C</td><td>Sound command</td></tr>
<tr><td>P</td><td>Parameter</td></tr>
</table>


<h3 id="SC-The-Sound-Editor">The Sound Editor</h3>

<p>Define and test your sounds here. The currently selected sound will
be used in the other editors for new notes.</p>


<h3 id="SC-Sound-Commands">Sound Commands</h3>

<p>These commands allow you to change parameters dynamically while
playback. Use them in the track editor.</p>

<table>
<tr><th>C</th><th>P</th><th>Purpose</th></tr>
<tr><td>0</td><td>0</td><td>No command</td></tr>
<tr><td>0</td><td>x</td><td>Mix (1=left, 2=right, 3=center/both)</td></tr>
<tr><td>1</td><td>x</td><td>Attack Time</td></tr>
<tr><td>2</td><td>x</td><td>Decay Time</td></tr>
<tr><td>3</td><td>x</td><td>Sustain Level</td></tr>
<tr><td>4</td><td>x</td><td>Release Time</td></tr>
<tr><td>5</td><td>x</td><td>LFO Rate</td></tr>
<tr><td>6</td><td>x</td><td>LFO Frequency Amount</td></tr>
<tr><td>7</td><td>x</td><td>LFO Volume Amount</td></tr>
<tr><td>8</td><td>x</td><td>LFO Pulse Width Amount</td></tr>
<tr><td>9</td><td>x</td><td>Pulse Width</td></tr>
<tr><td>D</td><td>x</td><td>Slow Speed (like E, but +16)</td></tr>
<tr><td>E</td><td>x</td><td>Speed (ticks per row, 8 by default)</td></tr>
<tr><td>F</td><td>0</td><td>Break Track/Pattern</td></tr>
<tr><td>F</td><td>1</td><td>Cut Note / Volume 0</td></tr>
</table>


<h1 id="Language-Basics">Language Basics</h1>

<p>The programming language of LowRes NX is based on
second-generation, structured BASIC (1985 style).</p>

<h2 id="Types-and-Variables">Types and Variables</h2>

<p>Available data types are strings and numbers (floating point).
Variable names can contain letters (A-Z), digits (0-9) and underscores
(_), but cannot begin with a digit. Reserved keywords cannot be used
as names, but they can contain them, for example:</p>
<p>
Valid: <code>ENDING</code><br/>
Invalid: <code>END</code>
</p>

<p>String variable names must end with a $ symbol, for example:</p>
<pre>NAME$</pre>

<p>Variables are not explicitly declared, but they need to be
initialized with a value before you can read from them. Values are
assigned to variables using the equal symbol:</p>
<pre>
NAME$="LOWRES NX"
LIVES=3
</pre>

<p>Hexadecimal and binary notation can be used for number values:</p>
<pre>
$FF02
%11001011
</pre>

<h2 id="Arrays">Arrays</h2>

<h3 id="_DIM" name="DIM">DIM</h3>

<pre>DIM [GLOBAL] var-list</pre>

<p>Defines arrays with the highest index for each dimension:</p>
<pre>
DIM A(100)
DIM MAP(31,23,1),NAMES$(9),SCORES(9)
</pre>

<p>Access elements from arrays, indices start from 0:</p>
<pre>
SCORES(0)=100
SCORES(9)=5
PRINT SCORES(0),SCORES(9)
</pre>

<p>All elements of arrays are automatically initialized, using zeros
(0) or empty strings ("").</p>

<p>With the optional GLOBAL keyword the arrays will be accessable
from all subprograms.</p>

<h2 id="Labels">Labels</h2>

<p>A label marks a position in a program and is used for commands
like GOTO. It consists of a name, using the same rules as for
variables, followed by a colon:</p>
<pre>
GAMEOVER:
</pre>

<h2 id="Operators">Operators</h2>

<h3 id="Operators-Ari">Arithmetic</h3>

<table>
<tr><th>Symbol</th> <th>Example</th> <th>Purpose</th></tr>
<tr><td>-</td> <td><code>-B</code></td> <td>Negation</td></tr>
<tr><td>^</td> <td><code>X^3</code></td> <td>Exponentiation</td></tr>
<tr><td>*</td> <td><code>2*Y</code></td> <td>Multiplication</td></tr>
<tr><td>/</td> <td><code>X/2</code></td> <td>Division</td></tr>
<tr><td>\</td> <td><code>X\2</code></td> <td>Integer Division</td></tr>
<tr><td>+</td> <td><code>C+2</code></td> <td>Addition</td></tr>
<tr><td>-</td> <td><code>100-D</code></td> <td>Subtraction</td></tr>
<tr><td>MOD</td> <td><code>X&#160;MOD&#160;2</code></td> <td>Modulo</td></tr>
</table>

<p>Operations are performed in mathematical order, for example
multiplications and divisions are performed before additions and
subtractions. The order can be specified explicitly through the use of
parentheses, for example: (3+4*3)/5</p>

<h3 id="Operators-Rel">Relational</h3>

<table>
<tr><th>Symbol</th> <th>Example</th> <th>Purpose</th></tr>
<tr><td>=</td> <td><code>A=10</code></td> <td>Equal</td></tr>
<tr><td>&lt;&gt;</td> <td><code>A&lt;&gt;100</code></td> <td>Not equal</td></tr>
<tr><td>&gt;</td> <td><code>B&gt;C</code></td> <td>Greater than</td></tr>
<tr><td>&lt;</td> <td><code>5&lt;X</code></td> <td>Less than</td></tr>
<tr><td>&gt;=</td> <td><code>X&gt;=20</code></td> <td>Greater than or equal</td></tr>
<tr><td>&lt;=</td> <td><code>X&lt;=30</code></td> <td>Less than or equal</td></tr>
</table>

<p>Relational operator expressions have a value of true (-1) or
false (0). For example: (2=3)=0, (4=4)=-1, (1&lt;3)=-1</p>

<h3 id="Operators-Log">Logical/Bitwise</h3>

<table>
<tr><th>Symbol</th> <th>Example</th> <th>Purpose</th></tr>
<tr><td>NOT</td> <td><code>NOT&#160;(X=15)<br/>NOT&#160;0</code></td> <td>"Not"</td></tr>
<tr><td>AND</td> <td><code>A=1&#160;AND&#160;B=12<br/>170&#160;AND&#160;15</code></td> <td>"And"</td></tr>
<tr><td>OR</td> <td><code>X=10&#160;OR&#160;Y=0<br/>128&#160;OR&#160;2</code></td> <td>"Or"</td></tr>
<tr><td>XOR</td> <td><code>A&#160;XOR&#160;B</code></td> <td>"Exclusive Or"</td></tr>
</table>

<h3 id="Operators-How">How to Use Operators</h3>

<p>All operators are available for numbers. Relational and addition
operators are usable with strings, too:</p>
<pre>
SUM=1+3
IF SUM&lt;5 THEN PRINT "LESS THAN 5"
NAME$="LOWRES NX"
GREET$="HELLO "+NAME$+"!"
IF NAME$&gt;"LOWRES" THEN PRINT GREET$
</pre>


<h1 id="Program-Flow-Control">Program Flow Control</h1>

<h2 id="Basics">Basics</h2>

<h3 id="_REM" name="REM">REM</h3>
<pre>
REM remark
' remark
</pre>

<p>Allows you to put comments into your program. REM lines are not
executed. You can use an apostrophe (') in place of the word REM.</p>


<h3 id="_IF-THEN-ELSE" name="IF,THEN,ELSE">IF...THEN...ELSE</h3>
<pre>
IF expr THEN command [ELSE command]
</pre>

<p>Checks if the given expression is true or false. If it's true, the
command after THEN is executed, otherwise the one after ELSE. The ELSE
part is optional.</p>
<p>If you want to execute more than one command, you can use the
block version of the IF command. It must be closed with the line
END IF.</p>

<pre>
IF expression THEN
    commands
[ELSE IF expression THEN]
    commands
[ELSE]
    commands
END IF
</pre>


<h3 id="_GOTO" name="GOTO">GOTO</h3>

<pre>GOTO label</pre>

<p>Jumps to the given label and continues the program execution there.
</p>


<h3 id="_GOSUB" name="GOSUB">GOSUB</h3>

<pre>GOSUB label</pre>

<p>Adds the current program position to a stack and jumps to the
given label. The program after the label is called a subroutine and
must be finished using RETURN.</p>

<p>NOTE: Subroutines exist mostly for historical reasons. You should
prefer the more powerful and safer subprograms.</p>


<h3 id="_RETURN" name="RETURN">RETURN</h3>

<pre>RETURN</pre>

<p>Jumps back to the position of the last call of GOSUB and removes
it from the stack.</p>

<pre>RETURN label</pre>

<p>Works like GOTO, but clears the whole stack. Use this to exit from
a subroutine, if you want to continue your program somewhere else.</p>


<h3 id="_END" name="END">END</h3>

<pre>END</pre>

<p>Stops the program from any position. The program is also stopped
automatically after the last line of code.</p>


<h3 id="_WAIT-VBL" name="WAIT VBL,WAIT,VBL">WAIT VBL</h3>

<pre>WAIT VBL</pre>

<p>Waits for the next frame. This (or WAIT n) should be the last
command in all loops which do animations and/or handle input,
like the main game loop.</p>


<h3 id="_WAIT" name="WAIT">WAIT</h3>

<pre>WAIT n</pre>

<p>Waits <em>n</em> frames (n/60 seconds), where the minimum for
<em>n</em> is 1.
Subprograms running from interrupts (ON VBL/RASTER, MUSIC) will
continue to work as normal during this period.</p>
<p>WAIT 1 is the same as WAIT VBL, so why is there WAIT VBL? Because
it looks cooler and nerdier! A little guideline: Use WAIT VBL in loops
for smooth animations and input handling, and WAIT n if you actually
want to wait some time.</p>


<h2 id="Loops">Loops</h2>

<h3 id="_FOR-NEXT" name="FOR,TO,STEP,NEXT">FOR...NEXT</h3>
<pre>
FOR var=a TO b [STEP s]
    commands
NEXT var
</pre>

<p>Performs a series of commands in a loop a given number of times.
The FOR command uses the variable <em>var</em> as a counter, starting with the
value <em>a</em>. All commands until NEXT are executed, then the counter is
increased by <em>s</em> (or +1 if STEP is omitted). A check is performed to see
if the counter is now greater than <em>b</em>. If not, the process is repeated.
If it is greater, the program continues with the lines after NEXT. If
STEP <em>s</em> is negative, the loop is executed until the counter is less
than value <em>b</em>.</p>


<h3 id="_DO-LOOP" name="DO,LOOP">DO...LOOP</h3>
<pre>
DO
  commands
LOOP
</pre>

<p>Performs commands in an endless loop. You can use GOTO to exit it.
</p>


<h3 id="_REPEAT-UNTIL" name="REPEAT,UNTIL">REPEAT...UNTIL</h3>
<pre>
REPEAT
    commands
UNTIL expression
</pre>

<p>Executes the commands in a loop until the given expression is true.
The loop is executed at least once.</p>


<h3 id="_WHILE-WEND" name="WHILE,WEND">WHILE...WEND</h3>
<pre>
WHILE expression
    commands
WEND
</pre>

<p>Executes the commands in a loop as long as the given expression is
true.</p>


<h2 id="Subprograms">Subprograms</h2>

<h3 id="_SUB" name="SUB,END SUB,END">SUB...END SUB</h3>
<pre>
SUB name [(parameter-list)]
  commands
END SUB
</pre>

<p>Defines a subprogram with the given name. The optional parameter
list can contain two types of entries: simple variables and array
variables (followed by an empty parentheses pair). Entries are
separated by commas. By default all variables inside the subprogram
are local.</p>

<p>NOTE: Don't use GOTO or GOSUB to jump out of a subprogram!</p>


<h3 id="_CALL" name="CALL">CALL</h3>
<pre>
CALL name [(argument-list)]
</pre>

<p>Executes the subprogram with the given name and returns to the
current position after finishing it. The argument list
must match the parameters of the SUB definition. Simple variables,
single array elements and entire arrays (followed by an empty parentheses pair) are passed by reference to the subprogram. Other
expressions are passed by value.</p>


<h3 id="_EXIT-SUB" name="EXIT SUB,EXIT,SUB">EXIT SUB</h3>
<pre>
EXIT SUB
</pre>

<p>Exits a subprogram before END SUB is reached.</p>


<h3 id="_GLOBAL" name="GLOBAL">GLOBAL</h3>
<pre>
GLOBAL variable-list
</pre>

<p>Makes variables from the main program available to all subprograms.
The list can contain simple variables only. For arrays you should use
DIM GLOBAL. This command cannot be used within a subprogram.</p>


<h1 id="Text">Text</h1>

<h3 id="_PRINT" name="PRINT">PRINT</h3>

<pre>PRINT expression-list</pre>

<p>Outputs text to the current window. Expressions can be strings or
numbers, separated by commas or semicolons. A comma separates the
output with a space, a semicolon outputs without space.
End the list with a comma or semicolon to keep the cursor at the
end of the output, otherwise a new line is started.</p>


<h3 id="_INPUT" name="INPUT">INPUT</h3>

<pre>INPUT ["prompt";]var</pre>

<p>Lets the user enter a text or number on the keyboard and stores it
in the variable <em>var</em>. Optionally it can show a prompt text before
(cannot be a variable).</p>
<p>INPUT automatically enables the keyboard.</p>


<h3 id="_LOCATE" name="LOCATE">LOCATE</h3>

<pre>LOCATE cx,cy</pre>

<p>Moves the text cursor to column <em>cx</em> and row <em>cy</em>
relative to the current window.</p>


<h3 id="_WINDOW" name="WINDOW">WINDOW</h3>

<pre>WINDOW cx,cy,w,h,b</pre>

<p>Sets the text output window to cell position <em>cx,cy</em> and sets the size
to <em>w</em> columns and <em>h</em> rows. Text will be written to background <em>b</em> (0
or 1).</p>

<h3 id="_CLW" name="CLW">CLW</h3>

<pre>CLW</pre>

<p>Clears the window with spaces and resets the text cursor position.
</p>


<h1 id="User-Input">User Input</h1>

<h2 id="Gamepads">Gamepads</h2>

<h3 id="_GAMEPAD" name="GAMEPAD">GAMEPAD</h3>
    
<pre>GAMEPAD n</pre>

<p>Enables gamepads for <em>n</em> (1 or 2) players. Once the gamepad is
enabled, the program cannot change to touchscreen/mouse input anymore.
</p>


<h3 id="_UP-DOWN-LEFT-RIGHT" name="=UP,DOWN,LEFT,RIGHT">=UP/DOWN/LEFT/RIGHT</h3>

<pre>
UP(p)
DOWN(p)
LEFT(p)
RIGHT(p)
</pre>

<p>Returns true if the given direction is currently pressed on the
direction pad of player <em>p</em> (0/1).</p>

<pre>
UP TAP(p)
DOWN TAP(p)
LEFT TAP(p)
RIGHT TAP(p)
</pre>

<p>With the optional TAP keyword, this function returns true only for
the first frame the button is pressed.</p>


<h3 id="_BUTTON" name="BUTTON,TAP">=BUTTON</h3>

<pre>BUTTON(p[,n])</pre>

<p>Returns true if button A (<em>n</em>=0) or B (<em>n</em>=1) is currently pressed by
player <em>p</em> (0/1). If the parameter <em>n</em> is omitted, both buttons
(A and B) are checked.</p>

<pre>BUTTON TAP(p[,n])</pre>

<p>With the optional TAP keyword, this function returns true only for
the first frame the button is pressed.</p>


<h3 id="_PAUSE-ON-OFF" name="PAUSE ON,PAUSE OFF,PAUSE,ON,OFF">PAUSE ON/OFF</h3>

<pre>
PAUSE ON
PAUSE OFF
</pre>

<p>Enables or disables the automatic pause handling. By default it's
enabled, so if you press the pause button, the program stops and
shows "PAUSE" on the screen, until the button is pressed again.</p>


<h3 id="_PAUSE" name="PAUSE">PAUSE</h3>

<pre>
PAUSE
</pre>

<p>Pauses the program and shows the default "PAUSE" screen, even if
automatic pause handling is disabled.</p>


<h3 id="_=PAUSE" name="PAUSE">=PAUSE</h3>

<pre>
PAUSE
</pre>

<p>Returns true if the pause button was pressed, otherwise false.
After calling this function its value is cleared, so it returns
each button tap only once. The automatic pause handling needs to
be disabled for this function.</p>


<h2 id="Touchscreen-Mouse">Touchscreen/Mouse</h2>

<p>Use touchscreen support only if you think it will work well with a
computer mouse, too. If you want to create your own game buttons,
keep in mind that your game might be unplayable on a computer,
because it won't support the keyboard or a real gamepad. Always
consider using the standard gamepad functions.</p>


<h3 id="_TOUCHSCREEN" name="TOUCHSCREEN">TOUCHSCREEN</h3>

<pre>
TOUCHSCREEN
</pre>

<p>Enables the touchscreen/mouse support. Once it's enabled, the
program cannot change to gamepad input anymore.</p>


<h3 id="_TOUCH.X-TOUCH.Y" name="TOUCH.X,TOUCH.Y">=TOUCH.X/Y</h3>
<pre>
TOUCH.X
TOUCH.Y
</pre>

<p>Returns the current X or Y pixel position where the user touches
the screen, or where it was touched the last time.</p>


<h3 id="_TOUCH" name="TOUCH">=TOUCH</h3>

<pre>TOUCH</pre>

<p>Returns true if the screen is currently touched.</p>


<h3 id="_TAP" name="TAP">=TAP</h3>

<pre>TAP</pre>

<p>Returns true if the screen is currently touched and was not
touched the last frame.</p>


<h2 id="Keyboard">Keyboard</h2>

<h3 id="_KEYBOARD-ON-OFF-OPTIONAL" name="KEYBOARD ON,KEYBOARD OFF,KEYBOARD OPTIONAL,KEYBOARD,ON,OFF,OPTIONAL">KEYBOARD ON/OFF/OPTIONAL</h3>

<pre>
KEYBOARD ON
KEYBOARD OFF
</pre>

<p>Enables or disables the keyboard. While the keyboard is enabled,
gamepads don't work.</p>

<pre>
KEYBOARD OPTIONAL
</pre>

<p>Enables the keyboard, but won't show an on-screen keyboard on
touchscreen devices. Programs using this mode should be completely
usable with gamepad or touch control and use the keyboard for
alternative input only.</p>


<h3 id="_INKEY$" name="INKEY$">=INKEY$</h3>

<pre>INKEY$</pre>

<p>Returns the last pressed key as a string. If no key was pressed,
it returns an empty string (""). After calling this function its
value is cleared, so it returns each pressed key only once.
The keyboard needs to be enabled for this function.</p>


<h1 id="Graphics">Graphics</h1>

<p>All graphics in LowRes NX are based on characters. A character is an
8x8-pixel image with 3 colors plus transparent. They are usually
designed in black and white, but are displayed with one of the 8
programmable color palettes.</p>

<p>At program start all characters from ROM entry 2 are copied to
video RAM to make them immediately usable.</p>

<p>The display is composed of 3 layers, which are from back to front:</p>
<ul>
<li>Background 1 (BG 1)</li>
<li>Background 0 (BG 0)</li>
<li>Sprites</li>
</ul>

<p>Each sprite and background cell has an attribute called "priority".
By setting it, the cell or sprite will appear on a higher display
layer. Actually there are 6 layers, from back to front:</p>
<ul>
<li>Background 1 (BG 1) - prio 0</li>
<li>Background 0 (BG 0) - prio 0</li>
<li>Sprites - prio 0</li>
<li>Background 1 (BG 1) - prio 1</li>
<li>Background 0 (BG 0) - prio 1</li>
<li>Sprites - prio 1</li>
</ul>


<h2 id="Sprites">Sprites</h2>

<p>Sprites are independent objects, which can be freely moved on the
screen. They can have a size of 8x8 pixels (one character) or up to
32x32 pixels by grouping several characters. Each sprite has the
standard character attributes (color palette, flip X/Y, priority) and additionally its size.</p>


<h3 id="_SPRITE" name="SPRITE">SPRITE</h3>

<pre>SPRITE n,[x],[y],[c]</pre>

<p>Sets the position <em>(x,y)</em> and character <em>(c)</em> of sprite <em>n</em> (0-63).
All parameters can be omitted to keep their current settings.</p>


<h3 id="_SPRITE-OFF" name="SPRITE OFF,SPRITE,OFF">SPRITE OFF</h3>

<pre>
SPRITE OFF [n]
SPRITE OFF a TO b
</pre>

<p>Hides one or more sprites. If all parameters are omitted, all sprites (0 - 63) are hidden. With one parameter only the given sprite is hidden. The last option is to hide sprites in the range from <em>a</em> to <em>b</em>.</p>


<h3 id="_SPRITE.A" name="SPRITE.A">SPRITE.A</h3>

<pre>SPRITE.A n,(pal,fx,fy,pri,s)</pre>

<p>Sets the attributes of sprite <em>n</em> (0-63). All attribute parameters
can be omitted to keep their current settings.</p>

<table>
<tr><td>pal</td> <td>palette number (0-7)</td></tr>
<tr><td>fx</td> <td>flip horizontally (0/1)</td></tr>
<tr><td>fy</td> <td>flip vertically (0/1)</td></tr>
<tr><td>pri</td> <td>priority flag (0/1)</td></tr>
<tr><td>s</td> <td>size (0-3):<br/>
0: 1 character (8x8 px)<br/>
1: 2x2 characters (16x16 px)<br/>
2: 3x3 characters (24x24 px)<br/>
3: 4x4 characters (32x32 px)</td></tr>
</table>

<pre>SPRITE.A n,a</pre>

<p>Allows setting the attributes as a single 8-bit value.</p>


<h3 id="_=SPRITE.X-Y" name="SPRITE.X,SPRITE.Y">=SPRITE.X/Y</h3>

<pre>
SPRITE.X(n)
SPRITE.Y(n)
</pre>

<p>Return the position of sprite <em>n</em>.</p>


<h3 id="_=SPRITE.C" name="SPRITE.C">=SPRITE.C</h3>

<pre>SPRITE.C(n)</pre>

<p>Returns the character of sprite <em>n</em>.</p>


<h3 id="_=SPRITE.A" name="SPRITE.A">=SPRITE.A</h3>

<pre>SPRITE.A(n)</pre>

<p>Returns the attributes of sprite <em>n</em> as an 8-bit value.</p>


<h3 id="_=SPRITE-HIT" name="SPRITE HIT,SPRITE,HIT">=SPRITE HIT</h3>

<pre>SPRITE HIT(n[,a [TO b]])</pre>

<p>Returns true if sprite <em>n</em> collides with another sprite (which means
that pixels overlap). If no more parameters are given, it will
check with all other visible sprites. If the <em>a</em> parameter is added,
it will check only with that sprite <em>a</em>. If all parameters are
given, it will check with all sprites from number <em>a</em> to number <em>b</em>.</p>


<h3 id="_=HIT" name="HIT">=HIT</h3>

<pre>HIT</pre>

<p>Returns the number of the sprite which collided with the sprite of
the last call of SPRITE HIT.</p>


<h2 id="Backgrounds">Backgrounds</h2>

<p>A background is a map of 32x32 character cells, which is used for text
and tile based maps or images. Each cell has the information of which
character it contains and additional attributes (color palette, flip
X/Y, priority).</p>

<p>As a character has the size of 8x8 pixels, the resulting background
size is 256x256 pixels, which is larger than the actual screen
(160x128). By modifying the scroll offset of a background, the visible
area can be moved.</p>

<p>If the visible area moves out of the borders of the background, the
display wraps around the edges. This can be used to achieve endless
scrolling.</p>

<p>There is a mode for 16x16-pixel cells. When active, each cell will show
2x2 characters, similar to big sprites. This mode also increases the
background size to 512x512 pixels. Use the DISPLAY command to enable
it.</p>

<p>For most of the commands and functions that access backgrounds
their cell co-ordinates can be outside of the background size (32x32).
They will be wrapped around the edges, so for example a character drawn
at position 34,-2 will actually appear at position 2,30.</p>


<h3 id="_CLS" name="CLS">CLS</h3>
    
<pre>CLS</pre>

<p>Clears both backgrounds with character 0 and resets the current
window to the default one.</p>

<pre>CLS b</pre>

<p>Clears background <em>b</em> with character 0.</p>


<h3 id="_ATTR" name="ATTR">ATTR</h3>

<pre>ATTR (pal,fx,fy,pri,s)[,m]</pre>

<p>Sets the current attributes for cell and text commands.
All attribute parameters can be omitted to keep their current
settings.</p>

<table>
<tr><td>pal</td> <td>palette number (0-7)</td></tr>
<tr><td>fx</td> <td>flip horizontally (0/1)</td></tr>
<tr><td>fy</td> <td>flip vertically (0/1)</td></tr>
<tr><td>pri</td> <td>priority flag (0/1)</td></tr>
<tr><td>s</td> <td>unused (0-3)</td></tr>
</table>

<p>The optional parameter <em>m</em> is an 8-bit binary number used as a mask.
It defines which bits of a cell attribute should actually be changed.</p>


<pre>ATTR a[,m]</pre>

<p>Allows setting the attributes as a single 8-bit value.</p>


<h3 id="_BG" name="BG">BG</h3>

<pre>BG n</pre>

<p>Sets the current background (0 or 1).</p>


<h3 id="_CELL" name="CELL">CELL</h3>

<pre>CELL cx,cy,[c]</pre>

<p>Sets the cell at position <em>cx,cy</em> of the current background to
character <em>c</em>. If <em>c</em> is omitted, only the attributes of the cell get
changed.</p>


<h3 id="_CELL.C" name="CELL.C">=CELL.C</h3>

<pre>CELL.C(cx,cy)</pre>

<p>Returns the character of the cell at position <em>cx,cy</em> of the current
background.</p>


<h3 id="_CELL.A" name="CELL.A">=CELL.A</h3>

<pre>CELL.A(cx,cy)</pre>

<p>Returns the attributes of the cell at position <em>cx,cy</em> of the current
background as an 8-bit value.</p>


<h3 id="_BG-FILL" name="BG FILL,BG,FILL,TO,CHAR">BG FILL</h3>

<pre>BG FILL cx1,cy1 TO cx2,cy2 [CHAR c]</pre>

<p>Sets all cells in the area from <em>cx1,cy1</em> to <em>cx2,cy2</em> of the current
background to character <em>c</em>. If CHAR <em>c</em> is omitted, only the attributes
of the cells get changed.</p>


<h3 id="_BG-SOURCE" name="BG SOURCE,BG,SOURCE">BG SOURCE</h3>

<pre>BG SOURCE a[,w,h]</pre>

<p>Sets the current source for the BG COPY command. The two-dimensional
map starts at memory address <em>a</em>, has a width of <em>w</em> and
a height of <em>h</em> cells.</p>

<p>Without the size parameters, Background Designer's data
format is assumed: The width is read from address <em>a</em>+2, the
height from <em>a</em>+3 and the actual map data starts at <em>a</em>+4.</p>

<p>By default ROM entry 3 is used as source.</p>


<h3 id="_BG-COPY" name="BG COPY,BG,COPY">BG COPY</h3>

<pre>BG COPY cx1,cy1,w,h TO cx2,cy2</pre>

<p>Copies a two-dimensional part of the current source to the
current background.</p>


<h3 id="_MCELL.C-MCELL.A" name="MCELL.C,MCELL.A,MCELL">=MCELL.C/A</h3>

<pre>MCELL.C(cx,cy)</pre>
<pre>MCELL.A(cx,cy)</pre>

<p>Work like the CELL.C and CELL.A functions, but get a cell from the
source map (BG SOURCE) instead of the current background. If the
co-ordinates are outside of the map bounds, the functions return -1.</p>


<h3 id="_MCELL" name="MCELL">MCELL</h3>

<pre>MCELL cx,cy,[c]</pre>

<p>Works like the CELL command, but sets a cell in the source map
(BG SOURCE) instead of the current background. The source must be in
working RAM, otherwise you will get an "Illegal Memory Access" error.</p>


<h3 id="_BG-SCROLL" name="BG SCROLL,BG,SCROLL,STEP">BG SCROLL</h3>

<pre>BG SCROLL cx1,cy1 TO cx2,cy2 STEP dx,dy</pre>

<p>Moves the content of all cells in the area from <em>cx1,cy1</em> to <em>cx2,cy2</em>
horizontally by <em>dx</em> and vertically by <em>dy</em> cells.</p>


<h3 id="_TEXT" name="TEXT">TEXT</h3>

<pre>TEXT cx,cy,s$</pre>

<p>Outputs the string <em>s$</em> to the current background at cell position
<em>cx,cy</em>.</p>


<h3 id="_NUMBER" name="NUMBER">NUMBER</h3>

<pre>NUMBER cx,cy,n,d</pre>

<p>Outputs the number <em>n</em> to the current background at cell position
<em>cx,cy</em>. The number is formatted to show always <em>d</em> digits.
This command is preferred over TEXT to show numbers, as it
doesn't need to convert numbers to strings.</p>


<h3 id="_FONT" name="FONT">FONT</h3>
    
<pre>FONT c</pre>

<p>Sets the current character range used for text output.
<em>c</em> is the character where the font starts (space).</p>

<p>The default value is 192, which points to the standard font,
if available.</p>


<h3 id="_SCROLL" name="SCROLL">SCROLL</h3>

<pre>SCROLL b,x,y</pre>

<p>Sets the scroll offset of background <em>b</em> (0/1) to pixel
co-ordinates <em>x,y</em>.</p>


<h3 id="_SCROLL.X-SCROLL.Y" name="SCROLL.X,SCROLL.Y">=SCROLL.X/Y</h3>

<pre>
SCROLL.X(b)
SCROLL.Y(b)
</pre>

<p>Return the scroll offset of background <em>b</em>.</p>


<h2 id="Display-Settings">Display Settings</h2>

<h3 id="_DISPLAY" name="DISPLAY">DISPLAY</h3>

<pre>DISPLAY (s,b0,b1,c0,c1)</pre>

<p>Sets the display attributes. All attribute parameters can be omitted to keep their current settings.</p>

<table>
<tr><td>s</td> <td>sprites enabled (0/1)</td></tr>
<tr><td>b0</td> <td>background 0 enabled (0/1)</td></tr>
<tr><td>b1</td> <td>background 1 enabled (0/1)</td></tr>
<tr><td>c0</td> <td>BG 0 cell size,</td></tr>
<tr><td>c1</td> <td>BG 1 cell size:<br/> 
0: 1 character (8x8 pixels)<br/>
1: 2x2 characters (16x16 pixels)</td></tr>
</table>

<pre>DISPLAY a</pre>

<p>Allows setting the attributes as a single 8-bit value.</p>


<h3 id="_=DISPLAY" name="DISPLAY">=DISPLAY</h3>

<pre>DISPLAY</pre>

<p>Returns the display attributes as an 8-bit value.</p>


<h3 id="_PALETTE" name="PALETTE">PALETTE</h3>

<pre>PALETTE n,[c0],[c1],[c2],[c3]</pre>

<p>Sets all four colors of palette <em>n</em> (0-7). Color 0 is only used for
palette 0 and shown as the screen's backdrop color. The color
parameters can be omitted to keep their current settings.
Valid color values are 0-63 and can be calculated like this:</p>
<pre>
VALUE = RED * 16 + GREEN * 4 + BLUE
</pre>
<p>RED, GREEN and BLUE are values from 0 to 3.</p>

<p>By default all palettes are read from ROM entry 1.</p>


<h3 id="_=COLOR" name="COLOR">=COLOR</h3>

<pre>COLOR(p,n)</pre>

<p>Returns the value of color <em>n</em> (0-3) from palette <em>p</em> (0-7).
You can get the RED, GREEN and BLUE values like this:</p>
<pre>
RED = INT(VALUE / 16)
GREEN = INT(VALUE / 4) MOD 4
BLUE = VALUE MOD 4
</pre>


<h3 id="_ON-RASTER-CALL" name="ON RASTER CALL,ON RASTER,RASTER CALL,ON,RASTER,CALL,ON RASTER OFF,RASTER OFF,OFF">ON RASTER CALL/OFF</h3>

<pre>ON RASTER CALL name</pre>

<p>Sets a subprogram which is executed for every screen line before
it's drawn. Usually used to change color palettes or scroll
offsets to achieve graphical effects. Raster subprograms must be
short (see "CPU Cycles").</p>

<pre>ON RASTER OFF</pre>

<p>Removes the current subprogram.</p>


<h3 id="_=RASTER" name="RASTER">=RASTER</h3>

<pre>RASTER</pre>

<p>Returns the current screen line (y position). Use this in a raster
subprogram.</p>


<h3 id="_ON-VBL-CALL" name="ON VBL CALL,ON VBL,VBL CALL,ON,VBL,CALL,ON VBL OFF,VBL OFF,OFF">ON VBL CALL/OFF</h3>

<pre>ON VBL CALL name</pre>

<p>Sets a subprogram which is executed each frame. Can be used
to update animations or sounds, even if the main program is
blocked by WAIT or INPUT. VBL subprograms should not be very long
(see "CPU Cycles").</p>

<pre>ON VBL OFF</pre>

<p>Removes the current subprogram.</p>


<h3 id="_=TIMER" name="TIMER">=TIMER</h3>

<pre>TIMER</pre>

<p>Returns the number of frames shown since LowRes NX was started.
The value wraps to 0 when 5184000 is reached, which is about 24
hours.</p>


<h1 id="Sound">Sound</h1>

<p>LowRes NX has four independent sound generators (voices). Each one
can play sawtooth, triangle, pulse and noise waveforms, and has
frequency, volume and pulse width settings. An additional envelope
generator and LFO per voice makes complex sounds and instruments
possible.</p>
<p>You can use the tool "Sound Composer" (or compatible programs) to
create music, tracks and sound presets.</p>


<h3 id="_MUSIC" name="MUSIC">MUSIC</h3>

<pre>MUSIC [p]</pre>

<p>Starts playback of a song at pattern <em>p</em>. If the parameter <em>p</em> is
omitted, it starts at pattern 0.</p>


<h3 id="_TRACK" name="TRACK">TRACK</h3>

<pre>TRACK n,v</pre>

<p>Plays track <em>n</em> once on voice <em>v</em>. Each voice can play a track
independently, so this can be used for sound effects, even while music
is playing.</p>


<h3 id="_PLAY" name="PLAY">PLAY</h3>

<pre>PLAY v,p[,len] [SOUND s]</pre>

<p>Plays a sound on voice <em>v</em> (0-3). <em>p</em> is the pitch:</p>
<table class="bigtable">
    <tr><th>Note</th><th colspan="8">Pitch (with different octaves)</th></tr>
    <tr><th>C</th><td>1</td><td>13</td><td>25</td><td>37</td><td>49</td><td>61</td><td>73</td><td>85</td></tr>
    <tr><th>C#</th><td>2</td><td>14</td><td>26</td><td>38</td><td>50</td><td>62</td><td>74</td><td>86</td></tr>
    <tr><th>D</th><td>3</td><td>15</td><td>27</td><td>39</td><td>51</td><td>63</td><td>75</td><td>87</td></tr>
    <tr><th>D#</th><td>4</td><td>16</td><td>28</td><td>40</td><td>52</td><td>64</td><td>76</td><td>88</td></tr>
    <tr><th>E</th><td>5</td><td>17</td><td>29</td><td>41</td><td>53</td><td>65</td><td>77</td><td>89</td></tr>
    <tr><th>F</th><td>6</td><td>18</td><td>30</td><td>42</td><td>54</td><td>66</td><td>78</td><td>90</td></tr>
    <tr><th>F#</th><td>7</td><td>19</td><td>31</td><td>43</td><td>55</td><td>67</td><td>79</td><td>91</td></tr>
    <tr><th>G</th><td>8</td><td>20</td><td>32</td><td>44</td><td>56</td><td>68</td><td>80</td><td>92</td></tr>
    <tr><th>G#</th><td>9</td><td>21</td><td>33</td><td>45</td><td>57</td><td>69</td><td>81</td><td>93</td></tr>
    <tr><th>A</th><td>10</td><td>22</td><td>34</td><td>46</td><td>58</td><td>70</td><td>82</td><td>94</td></tr>
    <tr><th>A#</th><td>11</td><td>23</td><td>35</td><td>47</td><td>59</td><td>71</td><td>83</td><td>95</td></tr>
    <tr><th>B</th><td>12</td><td>24</td><td>36</td><td>48</td><td>60</td><td>72</td><td>84</td><td>96</td></tr>
</table>

<p>The optional parameter <em>len</em> is the length in 1/60 seconds, the maximum
is 255. 0 means, that the the sound won't stop automatically. If the
parameter is omitted, the current value of the voice is kept.</p>

<p>By default the current sound settings of the voice are used. Add
the SOUND parameter to use the sound number <em>s</em> from the Sound Composer
tool.</p>


<h3 id="_STOP" name="STOP">STOP</h3>

<pre>STOP [v]</pre>

<p>Stops the current sound and track on voice <em>v</em>. If the parameter is
omitted, all voices, tracks and music are stopped. If a voice's
envelope has a release time, the sound won't stop immediately, but
fade out.</p>


<h3 id="_VOLUME" name="VOLUME">VOLUME</h3>

<pre>VOLUME v,[vol],[mix]</pre>

<p>Sets the volume of voice <em>n</em> (0-3) to <em>vol</em> (0-15) and its outputs to
<em>mix</em> (0-3):</p>

<table>
<tr><td>0</td><td>Muted</td></tr>
<tr><td>1</td><td>Left</td></tr>
<tr><td>2</td><td>Right</td></tr>
<tr><td>3</td><td>Left and right (center)</td></tr>
</table>

<p>All parameters can be omitted to keep their current settings.</p>


<h3 id="_SOUND" name="SOUND">SOUND</h3>

<pre>SOUND v,[w],[pw],[len]</pre>

<p>Sets the basic sound parameters of voice <em>v</em> (0-3).</p>
<p><em>w</em> is the waveform:</p>

<table>
<tr><td>0</td><td>Sawtooth</td></tr>
<tr><td>1</td><td>Triangle</td></tr>
<tr><td>2</td><td>Pulse</td></tr>
<tr><td>3</td><td>Noise</td></tr>
</table>

<p><em>pw</em> is the pulse width (0-15), a value of 8 results in a square
wave. This parameter only has an effect for the pulse waveform.</p>
<p><em>len</em> is the sound length in 1/60 seconds, the maximum is 255. 0 means,
that the sound won't stop automatically. If the length is set using
this command, the length parameter of PLAY can be omitted.</p>
<p>All parameters can be omitted to keep their current settings.</p>


<h3 id="_ENVELOPE" name="ENVELOPE">ENVELOPE</h3>

<pre>ENVELOPE v,[a],[d],[s],[r]</pre>

<p>Sets the volume envelope generator of voice <em>v</em> (0-3).</p>
<p><em>a</em> is the attack time, <em>d</em> is the decay time, and <em>r</em> is the release
time. All times are non-linear and range from 0 (2 ms) to 15 (12 s)</p>
<p><em>s</em> is the sustain level (0-15), which is the volume after the decay
time and before the sound gets released.</p>
<p>All parameters can be omitted to keep their current settings.</p>


<h3 id="_LFO" name="LFO">LFO</h3>

<pre>LFO v,[r],[fr],[vol],[pw]</pre>

<p>Sets the LFO (low frequency oscillator) of voice <em>v</em> (0-3).</p>
<p><em>r</em> is the LFO rate and ranges from 0 (0.12 Hz) to 15 (18 Hz) in a
non-linear manner.</p>
<p>The other paramters set the amount of the effect on different sound
parameters: <em>fr</em> for frequency/pitch, <em>vol</em> for volume and <em>pw</em> for pulse
width. These values range from 0 to 15.</p>
<p>All parameters can be omitted to keep their current settings.</p>


<h3 id="_LFO.A" name="LFO.A">LFO.A</h3>

<pre>LFO.A v,(w,r,e,t)</pre>

<p>Sets additional LFO attributes of voice <em>v</em> (0-3).
All attribute parameters can be omitted to keep their current settings.</p>

<table>
<tr><td>w</td> <td>wave (0-3):<br/>
0: triangle<br/>
1: sawtooth<br/>
2: square<br/>
3: random</td></tr>
<tr><td>r</td> <td>revert (0/1)</td></tr>
<tr><td>e</td> <td>env mode enabled (0/1)</td></tr>
<tr><td>t</td> <td>trigger enabled (0/1)</td></tr>
</table>

<p>By default the LFO adds its output to the normal sound parameters.
If revert is enabled, it subtracts.
By enabling the env mode, the LFO stops after one cycle, so it can
be used as an additional envelope generator. If the trigger is
enabled, the LFO restarts for each played sound, otherwise it runs
continuously. Trigger is enabled implicitly with the env mode.</p>


<h3 id="_SOUND-SOURCE" name="SOUND SOURCE,SOUND,SOURCE">SOUND SOURCE</h3>

<pre>SOUND SOURCE a</pre>

<p>Sets the current data source for the PLAY, MUSIC and TRACK
commands to the memory address <em>a</em>. This only affects the following
calls to these commands, already started playback keeps its own data
source. The data is assumed to be in the format of the Sound Composer
tool.</p>

<p>By default ROM entry 15 is used as source.</p>


<h1 id="Data">Data</h1>

<h3 id="_DATA" name="DATA">DATA</h3>

<pre>DATA constant-list</pre>

<p>Stores comma separated numeric and string constants (values, but
no variables or expressions) that are accessed by the READ
command. DATA commands are not executed and may be placed
anywhere in the program.</p>
<p>READ commands access DATA in order, from the top of a program
until the bottom. All constants of all DATA commands are read as
one continuous list of items.</p>


<h3 id="_READ" name="READ">READ</h3>

<pre>READ var-list</pre>

<p>Reads values from DATA commands and assigns them to the
comma separated variables in <em>var-list</em>. The program has an internal
pointer to the current DATA value. With each value read, the
pointer will move to the next DATA value.</p>


<h3 id="_RESTORE" name="RESTORE">RESTORE</h3>

<pre>RESTORE [label]</pre>

<p>Changes the internal read pointer to another position. This allows
to reread data or to select specific data. If the label parameter
is omitted, READ will start again from the top of the program.
Otherwise the pointer will be set to the jump label.</p>


<h1 id="Memory-Access">Memory Access</h1>

<p>LowRes NX simulates chips for graphics, sound and I/O, the cartridge
ROM, working RAM and persistent RAM. Everything is accessible in a
64 KB memory map, which is described in the chapter "Hardware
Reference".</p>


<h3 id="_=PEEK" name="PEEK">=PEEK</h3>

<pre>PEEK(a)</pre>

<p>Returns the byte value (0-255) at memory address <em>a</em>.</p>


<h3 id="_POKE" name="POKE">POKE</h3>

<pre>POKE a,v</pre>

<p>Sets the memory at address <em>a</em> to value <em>v</em>.
<em>v</em> is a numeric expression from 0 to 255;
numeric expressions outside this range are truncated to 8 bits.</p>


<h3 id="_=PEEKW" name="PEEKW">=PEEKW</h3>

<pre>PEEKW(a)</pre>

<p>Returns the two-byte value (-32768 to 32767) at memory
address <em>a</em>.</p>


<h3 id="_POKEW" name="POKEW">POKEW</h3>

<pre>POKEW a,v</pre>

<p>Writes a two-byte value at memory address <em>a</em>.
<em>v</em> is a numeric expression from -32768 to 32767;
numeric expressions outside this range are truncated to 16 bits.</p>


<h3 id="_=PEEKL" name="PEEKL">=PEEKL</h3>

<pre>PEEKL(a)</pre>

<p>Returns the four-byte value (-2147483648 to 2147483647) at
memory address <em>a</em>.</p>


<h3 id="_POKEL" name="POKEL">POKEL</h3>

<pre>POKEL a,v</pre>

<p>Writes a four-byte value at memory address <em>a</em>.
<em>v</em> is a numeric expression from -2147483648 to 2147483647;
numeric expressions outside this range are truncated to 32 bits.</p>


<h3 id="_COPY" name="COPY">COPY</h3>

<pre>COPY a,n TO d</pre>

<p>Copies <em>n</em> bytes starting from memory address <em>a</em> to address <em>d</em>.
The source and the destination areas may overlap.</p>


<h3 id="_FILL" name="FILL">FILL</h3>

<pre>FILL a,n[,v]</pre>

<p>Sets <em>n</em> bytes starting from memory address <em>a</em> to value <em>v</em>, or 0 if
the parameter is omitted.</p>


<h3 id="_ROL" name="ROL">ROL</h3>

<pre>ROL a,n</pre>

<p>Takes the byte at address <em>a</em> and rotates its bits left by <em>n</em> places.</p>


<h3 id="_ROR" name="ROR">ROR</h3>

<pre>ROR a,n</pre>

<p>Takes the byte at address <em>a</em> and rotates its bits right by <em>n</em> places.</p>


<h3 id="_=ROM" name="ROM">=ROM</h3>

<pre>ROM(n)</pre>

<p>Returns the memory address of ROM entry <em>n</em>.</p>


<h3 id="_=SIZE" name="SIZE">=SIZE</h3>

<pre>SIZE(n)</pre>

<p>Returns the number of bytes of ROM entry <em>n</em>.</p>


<h1 id="Files">Files</h1>

<p>The file commands can be used to store data on a
virtual disk, which can contain up to 16 files. Its format is the same
as the ROM entries part in a program file. This makes it possible to
use any NX program directly as a virtual disk to edit its data.</p>

<p>Virtual disks are meant to be used for development tools only, for
example image and map editors or music programs. Games should use
persistent memory instead. Imagine that the standard LowRes NX console
wouldn't have a disk drive.</p>


<h3 id="_LOAD" name="LOAD">LOAD</h3>

<pre>LOAD f,a</pre>

<p>Loads the file number <em>f</em> from the current virtual disk to memory starting
at address <em>a</em>.</p>

<p>LOAD is meant to be used for tools only. Use ROM entries for game
data.</p>


<h3 id="_SAVE" name="SAVE">SAVE</h3>

<pre>SAVE f,c$,a,n</pre>

<p>Saves <em>n</em> bytes starting at memory address <em>a</em> to the current virtual
disk as a file number <em>f</em> (0-15) with comment <em>c$</em> (up to 31 characters).</p>

<p>If this file was loaded before, consider keeping its original comment or
allow the user to edit it before saving. If the file is new, the comment
should contain at least the type of data, e.g. "CHARACTERS" or "MUSIC".</p>

<p>SAVE is meant to be used for tools only. Use persistent memory to
store game states.</p>


<h3 id="_FILES" name="FILES">FILES</h3>

<pre>FILES</pre>

<p>Loads the current file directory for use with FILES$.</p>


<h3 id="_FILE" name="FILE$">=FILE$</h3>

<pre>FILE$(f)</pre>

<p>Returns the comment string of file number <em>f</em>. Call FILES before accessing the file directory to update its content, or use FILE$ directly after LOAD or SAVE.</p>


<h3 id="_=FSIZE" name="FSIZE">=FSIZE</h3>

<pre>FSIZE(n)</pre>

<p>Returns the number of bytes of file number <em>n</em>. Call FILES before accessing the file directory to update its content, or use FSIZE directly after LOAD or SAVE.</p>


<h1 id="System">System</h1>

<h3 id="_TRACE" name="TRACE">TRACE</h3>

<pre>TRACE expression-list</pre>

<p>Outputs text to the debugging window. Expressions can be strings or
numbers, separated by commas. This command is ignored if the debugging
mode is not enabled.</p>


<h3 id="_SYSTEM" name="SYSTEM">SYSTEM</h3>

<pre>SYSTEM n,v</pre>

<p>TODO</p>


<h1 id="Math-Functions">Math Functions</h1>

<h2 id="Trigonometric">Trigonometric</h2>

<h3 id="_PI" name="PI">=PI</h3>

<pre>PI</pre>

<p>PI is the ratio of the circumference of a circle to its diameter:
3.1415926535...</p>


<h3 id="_SIN" name="SIN">=SIN</h3>

<pre>SIN(x)</pre>

<p>The sine of <em>x</em>, where <em>x</em> is in radians.</p>


<h3 id="_COS" name="COS">=COS</h3>

<pre>COS(x)</pre>

<p>The cosine of <em>x</em>, where <em>x</em> is in radians.</p>


<h3 id="_TAN" name="TAN">=TAN</h3>

<pre>TAN(x)</pre>

<p>The tangent of <em>x</em>, where <em>x</em> is in radians.</p>


<h3 id="_ASIN" name="ASIN">=ASIN</h3>

<pre>ASIN(x)</pre>

<p>The arc sine of <em>x</em>, where <em>x</em> must be in the range of -1 to +1. The range of the function is <span class="nobr">-(PI/2)</span> &lt; ASIN(x) &lt; (PI/2).</p>


<h3 id="_ACOS" name="ACOS">=ACOS</h3>

<pre>ACOS(x)</pre>

<p>The arc cosine of <em>x</em>, where <em>x</em> must be in the range of -1 to +1. The range of the function is <span class="nobr">-(PI/2)</span> &lt; ACOS(x) &lt; (PI/2).</p>


<h3 id="_ATAN" name="ATAN">=ATAN</h3>

<pre>ATAN(x)</pre>

<p>The arctangent of <em>x</em> in radians, i.e. the angle whose tangent is <em>x</em>.
The range of the function is <span class="nobr">-(PI/2)</span> &lt; ATAN(x) &lt; (PI/2).</p>


<h3 id="_HSIN" name="HSIN">=HSIN</h3>

<pre>HSIN(x)</pre>

<p>The hyperbolic sine of <em>x</em>.</p>


<h3 id="_HCOS" name="HCOS">=HCOS</h3>

<pre>HCOS(x)</pre>

<p>The hyperbolic cosine of <em>x</em>.</p>


<h3 id="_HTAN" name="HTAN">=HTAN</h3>

<pre>HTAN(x)</pre>

<p>The hyperbolic tangent of <em>x</em>.</p>


<h2 id="Standard-Math">Standard Math</h2>

<h3 id="_ABS" name="ABS">=ABS</h3>

<pre>ABS(x)</pre>

<p>The absolute value of <em>x</em>.</p>


<h3 id="_SGN" name="SGN">=SGN</h3>

<pre>SGN(x)</pre>

<p>The sign of <em>x</em>: -1 if <em>x</em> &lt; 0, 0 if <em>x</em> = 0 and +1 if <em>x</em> &gt; 0.</p>


<h3 id="_INT" name="INT">=INT</h3>

<pre>INT(x)</pre>

<p>The largest integer not greater than <em>x</em>; e.g. INT(1.3) = 1 and
INT(-1.3) = -2.</p>


<h3 id="_EXP" name="EXP">=EXP</h3>

<pre>EXP(x)</pre>

<p>The exponential of <em>x</em>, i.e. the value of the base of natural
logarithms (e = 2,71828...) raised to the power <em>x</em>.</p>


<h3 id="_LOG" name="LOG">=LOG</h3>

<pre>LOG(x)</pre>

<p>The natural logarithm of <em>x</em>; <em>x</em> must be greater than zero.</p>


<h3 id="_SQR" name="SQR">=SQR</h3>

<pre>SQR(x)</pre>

<p>The nonnegative square root of <em>x</em>; <em>x</em> must be nonnegative.</p>


<h2 id="Random-Sequences">Random Sequences</h2>

<h3 id="_RND" name="RND">=RND</h3>

<pre>RND</pre>

<p>The next number in a sequence of random numbers uniformly
distributed in the range 0 &lt;= RND &lt; 1.</p>

<pre>RND(n)</pre>

<p>The second syntax generates a random integer between 0 and <em>n</em> inclusive.</p>


<h3 id="_RANDOMIZE" name="RANDOMIZE,TIMER">RANDOMIZE</h3>
<pre>RANDOMIZE x</pre>

<p>Sets the seed for random numbers to <em>x</em>, which should be an integer
value. By default a program starts with seed 0, so the sequence of
random numbers is always the same.</p>

<pre>RANDOMIZE TIMER</pre>

<p>If you want different random numbers each time you run your
program, you should insert this line at the beginning.</p>


<h2 id="Manipulating-Numbers">Manipulating Numbers</h2>

<h3 id="_MIN" name="MIN">=MIN</h3>

<pre>MIN(x,y)</pre>

<p>The MIN function returns the smallest value of two expressions.</p>


<h3 id="_MAX" name="MAX">=MAX</h3>

<pre>MAX(x,y)</pre>

<p>The MAX function returns the largest value of two expressions.</p>


<h3 id="_SWAP" name="SWAP">SWAP</h3>

<pre>SWAP var1,var2</pre>

<p>Swaps the data between any two variables of the same type.</p>


<h3 id="_INC" name="INC">INC</h3>

<pre>INC var</pre>

<p>Increases the value of the variable by one. INC A does the same as A=A+1, but costs less CPU cycles.</p>


<h3 id="_DEC" name="DEC">DEC</h3>

<pre>DEC var</pre>

<p>Decreases the value of the variable by one. DEC A does the same as A=A-1, but costs less CPU cycles.</p>

<p></p>


<h3 id="_ADD" name="ADD">ADD</h3>

<pre>ADD var,x</pre>

<p>Adds the value <em>x</em> to the variable, where <em>x</em> can the positive or negative. ADD A,X does the same as A=A+X, but costs less CPU cycles.</p>

<pre>ADD var,x,base TO top</pre>

<p>The second syntax of ADD helps with repeating counters. It's the same as:</p>

<pre>
A=A+X
IF A&gt;TOP THEN A=BASE
IF A&lt;BASE THEN A=TOP
</pre>

<p>But again the ADD command costs less CPU cycles.</p>


<h1 id="String-Functions">String Functions</h1>

<h3 id="_LEFT$" name="LEFT$">=LEFT$=</h3>

<pre>LEFT$(s$,n)</pre>

<p>Returns a new string with the first <em>n</em> characters of <em>s$</em>.</p>

<pre>LEFT$(s$,n)=a$</pre>

<p>Overwrites the first characters in the variable <em>s$</em> with the first
<em>n</em> characters of <em>a$</em>.</p>


<h3 id="_RIGHT$" name="RIGHT$">=RIGHT$=</h3>

<pre>RIGHT$(s$,n)</pre>

<p>Returns a new string with the last <em>n</em> characters of <em>s$</em>.</p>

<pre>RIGHT$(s$,n)=a$</pre>

<p>Overwrites the last characters in the variable <em>s$</em> with the last <em>n</em>
characters of <em>a$</em>.</p>


<h3 id="_MID$" name="MID$">=MID$=</h3>

<pre>MID$(s$,p,n)</pre>

<p>Returns a new string with <em>n</em> characters of <em>s$</em>, starting at
character <em>p</em>. The first character has the position 1.</p>

<pre>MID$(s$,p,n)=a$</pre>

<p>Overwrites the given text range in the variable <em>s$</em> with the first
<em>n</em> characters of <em>a$</em>.</p>


<h3 id="_INSTR" name="INSTR">=INSTR</h3>

<pre>INSTR(d$,s$[,p])</pre>

<p>Searches the first occurrence of <em>s$</em> inside of <em>d$</em> and returns its
start position. If it's not found, the function returns 0.
Usually the function starts searching at the beginning of the
string. Optionally it can start searching at position <em>p</em>.</p>


<h3 id="_CHR$" name="CHR$">=CHR$</h3>

<pre>CHR$(n)</pre>

<p>Returns a string containing one character with ASCII code <em>n</em>.</p>


<h3 id="_ASC" name="ASC">=ASC</h3>

<pre>ASC(a$)</pre>

<p>Supplies you with the ASCII code of the first character of <em>a$</em>.</p>


<h3 id="_LEN" name="LEN">=LEN</h3>

<pre>LEN(a$)</pre>

<p>Returns the number of characters in <em>a$</em>.</p>


<h3 id="_VAL" name="VAL">=VAL</h3>

<pre>VAL(a$)</pre>

<p>Converts a number written in <em>a$</em> into a numeric value.</p>


<h3 id="_STR$" name="STR$">=STR$</h3>

<pre>STR$(n)</pre>

<p>Converts the number <em>n</em> into a string.</p>


<h3 id="_BIN$" name="BIN$">=BIN$</h3>

<pre>BIN$(n[,len])</pre>

<p>Converts the number <em>n</em> into a binary string with at least
<em>len</em> digits.</p>


<h3 id="_HEX$" name="HEX$">=HEX$</h3>

<pre>HEX$(n[,len])</pre>

<p>Converts the number <em>n</em> into a hexadecimal string with at least
<em>len</em> digits.</p>


<h1 id="Advanced-Topics">Advanced Topics</h1>

<h2 id="CPU-Cycles">CPU Cycles</h2>

<p>LowRes NX has a simplified simulation of CPU cycles. There is a
fixed limit of cycles per frame. This assures the same program
execution speed on all devices, so if you optimize your program on
your device to run smoothly, it will run the same on all other
devices.</p>

<p>Each execution of a command, function or operator, as well as
access to a variable or a constant count 1 cycle. Some operations have
additional costs:</p>
<ul>
<li>String creation and modification count 1 cycle per letter.</li>
<li>Array initialization counts 1 cycle per element.</li>
<li>Memory area modification counts 1 cycle per byte (not single byte
modifications like POKE).</li>
<li>BG area modification and text output count 2 cycles per cell (not
single cell modifications like CELL).</li>
</ul>

<table>
<tr><td>Total cycles per frame</td><td>17556</td></tr>
<tr><td>Cycles per VBL interrupt</td><td>1140</td></tr>
<tr><td>Cycles per raster interrupt</td><td>51</td></tr>
</table>

<p>The main program may spend any number of cycles, but when the limit
is reached before a WAIT VBL or WAIT command, the execution continues
in the next frame. If interrupts exceed their limit, you will see
black scanlines on the screen.</p>


<h2 id="Hardware-Reference">Hardware Reference</h2>

<h3 id="Memory-Map">Memory Map</h3>

<pre>
$0000 - Cartridge ROM (32 KB)

$8000 - Character Data (4 KB)
$9000 - BG0 Data (2 KB)
$9800 - BG1 Data (2 KB)

$A000 - Working RAM (16 KB)

$E000 - Persistent RAM (4 KB)

$FE00 - Sprite Registers (256 B)
$FF00 - Color Registers (32 B)
$FF20 - Video Registers
$FF40 - Audio Registers
$FF70 - I/O Registers
</pre>

<h3 id="Character-Data">Character Data</h3>

<p>A character is an 8x8-pixel image with 2 bits per pixel, with a
resulting size of 16 bytes. The video RAM has space for 256
characters.</p>

<p>The first 8 bytes of a character contain the low bits of all its
pixels, followed by 8 more bytes containing the high bits of all
pixels.</p>

<h3 id="BG-Data">BG Data</h3>

<p>A background is a map of 32x32 character cells. Each cell occupies two
bytes:</p>
<pre>
- Character number
- Attributes:
    Bit  Purpose
    0-2  Palette number
    3    Flip X
    4    Flip Y
    5    Priority
    6-7  Unused
</pre>

<h3 id="Persistent-RAM">Persistent RAM</h3>

<p>Imagine it as a battery buffered RAM on the game cartridge. Use it
for data like game positions or high score tables. The content of the
persistent RAM will be saved automatically when you exit the program
and loaded when you run it. Each program saves its persistent RAM
separately.</p>

<h3 id="Sprite-Registers">Sprite Registers</h3>

<p>There are 64 sprites available, each occupies 4 bytes:</p>
<pre>
- X position
- Y position
- Character number
- Attributes:
    Bit  Purpose
    0-2  Palette number
    3    Flip X
    4    Flip Y
    5    Priority
    6-7  Size:
         0: 1 character (8x8 px)
         1: 2x2 characters (16x16 px)
         2: 3x3 characters (24x24 px)
         3: 4x4 characters (32x32 px)
</pre>
<p>Note: X and Y sprite position registers have an offset of 32,
so they can move out of the top/left screen borders without using
negative numbers. Using the BASIC commands, this offset is
removed for convenience.</p>

<h3 id="Color-Registers">Color Registers</h3>

<p>There are 8 palettes of each 4 colors. One color is one byte:</p>
<pre>
Bits  Component
0-1   Blue
2-3   Green
4-5   Red
</pre>

<h3 id="Video-Registers">Video Registers</h3>

<pre>
$FF20 - Attributes:
    Bit  Purpose
    0    Sprites enabled
    1    BG0 enabled
    2    BG1 enabled
    3    BG0 cell size,
    4    BG1 cell size:
         0: 1 character (8x8 px)
            (BG 256x256 px)
         1: 2x2 characters (16x16 px)
            (BG 512x512 px)

$FF21 - BG0 scroll offset X
$FF22 - BG0 scroll offset Y
$FF23 - BG1 scroll offset X
$FF24 - BG1 scroll offset Y
$FF25 - Scroll offset MSB
    (most significant bits)
    used for big cell size only:
    Bit  Purpose
    0    BG0 X+256
    1    BG0 Y+256
    2    BG1 X+256
    3    BG1 Y+256

$FF26 - Raster line
</pre>

<h3 id="Audio-Registers">Audio Registers</h3>

<p>There are registers for 4 voices:</p>
<pre>
$FF40 - Voice 0
$FF4C - Voice 1
$FF58 - Voice 2
$FF64 - Voice 3
</pre>

<p>Each voice occupies 12 bytes:</p>
<pre>
- Frequency low-byte
- Frequency high-byte
- Status:
    Bit  Purpose
    0-3  Volume
    4    Mix to left
    5    Mix to right
    6    Init
    7    Gate
- Peak meter (read only)
- Attributes:
    Bit  Purpose
    0-3  Pulse width
    4-5  Wave:
         0: Sawtooth
         1: Triangle
         2: Pulse
         3: Noise
    6    Timeout enabled
- Length (timeout)
- Envelope byte 1:
    Bit  Purpose
    0-3  Attack
    4-7  Decay
- Envelope byte 2:
    Bit  Purpose
    0-3  Sustain
    4-7  Release
- LFO attributes:
    Bit  Purpose
    0-1  Wave:
         0: Triangle
         1: Sawtooth
         2: Square
         3: Random
    2    Invert
    3    Env mode enabled
    4    Trigger enabled
- LFO settings byte 1:
    Bit  Purpose
    0-3  LFO Rate
    4-7  Frequency amount
- LFO settings byte 2:
    Bit  Purpose
    0-3  Volume amount
    4-7  Pulse width amount
- Reserved
</pre>
<p>Note: The frequency is a 16-bit value: f = hertz * 16</p>


<h3 id="I-O-Registers">I/O Registers</h3>

<pre>
$FF70 - Gamepad 0 status
$FF71 - Gamepad 1 status

Gamepad status:
    Bit  Purpose
    0    Up
    1    Down
    2    Left
    3    Right
    4    Button A
    5    Button B

$FF72 - Last touch X position
$FF73 - Last touch Y position
$FF74 - Last pressed key (ASCII code)
$FF75 - Status:
    Bit  Purpose
    0    Pause button
    1    Touch

$FF76 - Attributes:
    Bit  Purpose
    0-1  Gamepads enabled:
         0: off
         1: 1 player
         2: 2 players
    2    Keyboard enabled
    3    Touchscreen enabled
</pre>


<h2 id="Sound-Data-Format">Sound Data Format</h2>

<p>This is the format used for the PLAY, MUSIC and TRACK commands.
It's valid to store only the sound presets, if no MUSIC or TRACK
commands are used with this data. If any tracks are available, all
patterns must be stored. Empty tracks after the last used one don't
need to be stored.</p> 

<pre>
Offset - Content
0      - 16 sound presets
128    - 64 patterns
384    - 64 tracks
</pre>

<p>Each sound preset occupies 8 bytes and matches the format of the
audio registers of one voice, but without the first 4 bytes.</p>

<p>Each pattern occupies 4 bytes:</p>
<pre>
- Voice 0:
    Bit  Purpose
    0-6  Track index
         (64 = voice unused)
    7    Flag loop start
- Voice 1:
    Bit  Purpose
    0-6  Track index
         (64 = voice unused)
    7    Flag loop end
- Voice 2:
    Bit  Purpose
    0-6  Track index
         (64 = voice unused)
    7    Flag song stop
- Voice 3:
    Bit  Purpose
    0-6  Track index
         (64 = voice unused)
</pre>

<p>Each track occupies 96 bytes and consists of 32 entries with each 3
bytes:</p>
<pre>
- Note pitch (0 = empty)
- Data (ignored if note is 0):
    Bit  Purpose
    0-3  Volume
    4-7  Sound
- Control:
    Bit  Purpose
    0-3  Parameter
    4-7  Command
</pre>

</div>
</body>
</html>
