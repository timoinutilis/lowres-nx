<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>LowRes NX Manual</title>
<style>
body {
	font-family: sans-serif;
}
h1 {
	margin-top: 2em;
}
h2 {
	margin-top: 2em;
}
td, th {
    padding-right: 1em;
    vertical-align: top;
}
th {
    text-align: left;
}
a {
    text-decoration: none;
}
ul {
    padding-left: 25px;
}
li {
    margin-bottom: 0.5em;
}
</style>
</head>

<body>

<h1 id="Introduction">Introduction</h1>

<h2 id="What-is-LowRes-NX">What is LowRes NX?</h2>

<p>LowRes NX is a simulated retro game console, which can be programmed
in the classic BASIC language. It has its own technical
specifications, but it's very much inspired by actual 8-bit and 16-bit
game consoles. It doesn't only look and sound retro, but actually
works like classic hardware.</p>

<p>LowRes NX simulates graphics, sound and I/O chips and makes their
hardware registers accessable in its memory map. Although most of the
features are available via simple BASIC commands, it's possible to
program video, audio and I/O directly by accessing the memory.</p>

<p>Imagine LowRes NX as a handheld game console with a d-pad, two action
buttons and a little rubber keyboard below a slidable touchscreen.</p>

<h2 id="Specifications">Specifications</h2>

<ul>
<li>Cartridge ROM: 32 KB for gfx, music, any binary data</li>
<li>Code: BASIC, max 16384 tokens</li>
<li>Screen: 160x128 pixels, 60 Hz</li>
<li>Backgrounds: Two layers, tile-based, scrollable</li>
<li>Sprites: 64, max 32x32 pixels</li>
<li>Colors: 8 dynamic 6-bit palettes with 4 colors each</li>
<li>Sound: 4 voices, saw/tri/pulse/noise, pulse width, volume, ADSR, LFO</li>
<li>Input: Two game controllers with d-pad and two buttons + pause</li>
<li>Optional input: Keyboard and touch/mouse</li>
</ul>


<h2 id="Getting-Started">Getting Started</h2>

<p>Create a new program using the Plus button and type these lines:
</p>

<pre>
PRINT "WELCOME!"
PRINT "WHAT IS YOUR NAME?"
INPUT ">";N$
PRINT "HELLO ";N$;"!"
</pre>

<p>Now tap the Play button to run your program! This is a little
example using the keyboard. Let's try something with a gamepad. Create
another new program and type this:</p>

<pre>
GAMEPAD 1
X=76
Y=60
DO
 IF UP(0) THEN Y=Y-1
 IF DOWN(0) THEN Y=Y+1
 IF LEFT(0) THEN X=X-1
 IF RIGHT(0) THEN X=X+1
 SPRITE 0,X,Y,225
 WAIT VBL
LOOP
</pre>

<p>Run this program and you will see an "A" on the screen which you can
move around using the gamepad. With the program still running, tap the
menu button on the top right and select "Capture Program Icon".</p>

<p>Now exit the program and return to the "My Programs" screen. There
you will see your program with a new image. Long tap the icon and
select "Rename..." to give it a better name.</p>


<h1 id="Editing">Editing</h1>

<h2 id="Programs-And-Data">Programs And Data</h2>

<p>A program file contains a complete game or application, including all
its data, stored as simple text. The first part is the BASIC source code.
Please read the programming chapters for further explanation.</p>

<p>The second part are the cartridge ROM entries. These are up to 16
numbered data blocks, which can contain any kind of binary data, for
example graphics, level maps, music, etc. When the program is running,
all ROM entries are accessable in the first 32 KB of the memory.</p>

<p>To create and edit ROM entries, just open your program, tap the
Tools button and select a program. It will run and use your current program as a virtual disk to load and save data. Tools don't save
automatically, so don't forget to save before you exit them.</p>

<p>Open your previous program with the moving "A" and select
"Character Designer" from the Tools menu. Draw something as character
#1 (keep #0 empty), then tap on "Disk" and save as file 2 ("Main
Characters"). Now exit the Character Designer and you will see some
hexadecimal data below your program. This is your image! To see it,
change the line</p>
<pre>SPRITE 0,X,Y,225</pre>
<p>to</p>
<pre>SPRITE 0,X,Y,1</pre>
<p>and run your program. There it is!</p>


<h2 id="Standard-ROM-Entries">Standard ROM Entries</h2>

<p>For an easy start you should use the ROM entry numbers of the
following table. Their data is made ready for use automatically.
</p>
<table>
<tr><td>#0</td><td>Keep empty for default font</td></tr>
<tr><td>#1</td><td>Color palettes</td></tr>
<tr><td>#2</td><td>Characters (sprites, tiles)</td></tr>
<tr><td>#3</td><td>Background (tile map)</td></tr>
<tr><td>#15</td><td>Sounds and music</td></tr>
</table>

<p>If cartridge ROM entry 0 is not used by a program, the compiler adds
character data for the default font. It occupies the characters
192-255 and is automatically copied to video RAM on program start.
If you want to use the default font, make sure to keep ROM entry 0
unused.</p>


<h2 id="Character-Designer">Character Designer</h2>

<p>Use the Character Designer to draw your sprites and background
tiles. It shows images in grayscale only, black is used as
transparent background. Color palettes can be created later in the
Background Designer.</p>
<p>The Character Designer loads file number 2 on startup, but
keep in mind that it does not save automatically.</p>


<h3 id="CD-Main-Screen">Main Screen</h3>

<p>In the bottom part you see the 256 characters split into four pages.
There you can select the current one for editing. Keep the last page
empty, if you want to use the default font. Also character #0 should
be empty for a clean background.</p>
<p>The top left square is for drawing the current character using the
selected color.</p>

<table>
<tr><td>CLR</td><td>Clear the current character with the selected
color.</td></tr>
<tr><td>CUT</td><td>Copy and clear the current character.</td></tr>
<tr><td>COP</td><td>Copy the current character.</td></tr>
<tr><td>PAS</td><td>Paste the copied character.</td></tr>
<tr><td>DISK</td><td>Go to the disk menu.</td></tr>
<tr><td>16*16</td><td>Go to the 16x16-pixel edit screen.</td></tr>
<tr><td>FON</td><td>Copy the standard font to the current page.</td></tr>
<tr><td>NEW</td><td>Clear all characters.</td></tr>
</table>

<h3 id="CD-Disk-Menu">Disk Menu</h3>

<p>The list shows all 16 files of the current virtual disk, or in
other words the ROM entries of the program you are editing. Select one
(usually number 2) and tap on Load or Save.</p>


<h2 id="Background-Designer">Background Designer</h2>

<p>The Background Designer allows you to create tile-based screens or
level maps of different sizes. Additionally it's for creating color palettes. On the bottom right there are three tabs for the different
sections of the program: The map editor, the selection screen and
the disk menu.</p>
<p>The Background Designer loads the main characters (file 1),
palettes (file 2) and background (file 3) on startup, but keep in
mind that it doesn't save automatically.</p>


<h3 id="BD-Selection-Screen">Selection Screen</h3>

<p>On the top there is the character selector. Drag to select several
characters at once. In the box at the left you select the current
color palette. On the right you can edit each color of the current
palette using the RGB sliders. The first color is usually transparent
and unused, except the first color of palette 0, which is used as the
screen backdrop color.
</p>


<h3 id="BD-Map-Editor">Map Editor</h3>

<p>Here you draw your background using the character and color palette
currently selected on the selection screen. On the bottom appear some
tools:</p>

<table>
<tr><td>Pan</td><td>Drag the visible map area.</td></tr>
<tr><td>Stamp</td><td>Draw with the selected character and color
palette, using the selected flip and priority attributes.</td></tr>
<tr><td>Paint</td><td>Change the color palette only.</td></tr>
<tr><td>Priority</td><td>Change the priority only. Cells with priority
1 are shown in green, all others in red.</td></tr>
<tr><td>FLIP</td><td>Toggles the X/Y flip attributes.</td></tr>
<tr><td>PRI</td><td>Toggles the priority attribute.</td></tr>
</table>


<h3 id="BD-Disk-Menu">Disk Menu</h3>

<p>From here you load and save characters, color palettes and the
background separately. There is no option to save everything at once.
For the background there are two additional options:</p>

<table>
<tr><td>NEW</td><td>Clear the complete background (keeping its size).
</td></tr>
<tr><td>SIZE</td><td>Go to the size menu, where you can choose
the width and height of the background (in cells), as well as the cell size (8x8 or 16x16 pixels).</td></tr>
</table>


<h2 id="Sound-Composer">Sound Composer</h2>

<p>The Sound Composer serves to create sound presets, sequences
("tracks") and complete songs.</p>
<p>It loads the main sound data (file 15) on startup, but keep in mind
that it doesn't save automatically. A sound file includes all sound
and music data.</p>


<h3 id="SC-Structure">Structure</h3>

<p>- 16 Sounds</p>
<p>A sound is a preset with all available sound parameters (waveform,
envelope, LFO, etc.). It can be used directly with the PLAY command in
your program or as an instrument in a track/song.</p>

<p>- 64 Tracks</p>
<p>A track is a sequence of 32 steps for a single voice, where each
step can play a note or modify the sound. It can be used in your
program for complex sound effects and short melodies (e.g. "level up")
with the TRACK command. Tracks are also used to create songs.</p>

<p>- 64 Patterns</p>
<p>A pattern is a block of music, which defines which track should be
played on each of the four voices. Patterns will be played one after
another, except in the following cases: If the next pattern is empty,
the song is stopped. When the current pattern finishes and has a "loop
end" flag, the player jumps back to the previous pattern with a "loop
start" flag. When a pattern finishes and has a "stop" flag, the player
stops.<br/>
If you want to create music for a game and you plan to use
additional sound effects, you should leave at least one voice empty.</p>

- Songs
<p>The 64 patterns can be used for one long song or several shorter
ones. By using the "loop" and "stop" flags songs can be separated. To
play one specific song, just start at its first pattern. To play a
song in your program use the MUSIC command.</p>


<h3 id="SC-Editors">Editors</h3>

<p>The Sound Composer has three tabs in the top right corner for the
different sections: The pattern editor, the track editor and the sound
editor. This is a "Tracker"-style program, which means the timeline
goes from top to bottom, not from left to right. So the steps in a
track are also called rows. Most values in the range from 0 to 15 are
shown in hexadecimal format (0-F).</p>

<h3 id="SC-The-Pattern-Editor">The Pattern Editor</h3>
<p>Here you can select a pattern, choose its tracks for all voices and
edit directly the notes of each selected track. There is also a toggle
button for the "loop" and "stop" flags for the current pattern. If you
set notes in a voice without track, it selects automatically a free
track. Use the star symbol from the musical keyboard, if you want to
stop/release a note in a track.</p>

<h3 id="SC-The-Track-Editor">The Track Editor</h3>
<p>Here you can select and edit a single track with additional
parameters:</p>
<table>
<tr><td>S</td><td>Sound</td></tr>
<tr><td>V</td><td>Volume</td></tr>
<tr><td>C</td><td>Sound command</td></tr>
<tr><td>P</td><td>Parameter</td></tr>
</table>


<h3 id="SC-The-Sound-Editor">The Sound Editor</h3>

<p>Define and test your sounds here. The currently selected sound will
be used in the other editors for new notes.</p>


<h3 id="SC-Sound-Commands">Sound Commands</h3>

<p>These commands allow you to change parameters dynamically while
playback.</p>

<table>
<tr><th>C</th><th>P</th><th>Purpose</th></tr>
<tr><td>0</td><td>0</td><td>No command</td></tr>
<tr><td>0</td><td>x</td><td>Mix (1=left, 2=right, 3=center/both)</td></tr>
<tr><td>1</td><td>x</td><td>Attack Time</td></tr>
<tr><td>2</td><td>x</td><td>Decay Time</td></tr>
<tr><td>3</td><td>x</td><td>Sustain Level</td></tr>
<tr><td>4</td><td>x</td><td>Release Time</td></tr>
<tr><td>5</td><td>x</td><td>LFO Rate</td></tr>
<tr><td>6</td><td>x</td><td>LFO Frequency Amount</td></tr>
<tr><td>7</td><td>x</td><td>LFO Volume Amount</td></tr>
<tr><td>8</td><td>x</td><td>LFO Pulse Width Amount</td></tr>
<tr><td>9</td><td>x</td><td>Pulse Width</td></tr>
<tr><td>E</td><td>x</td><td>Speed (ticks per row, 8 by default)</td></tr>
<tr><td>F</td><td>0</td><td>Break Track/Pattern</td></tr>
<tr><td>F</td><td>1</td><td>Cut Note / Volume 0</td></tr>
</table>


<h1 id="Language-Basics">Language Basics</h1>

<p>The programming language of LowRes NX is based on
second-generation, structured BASIC (1985 style).</p>

<h2 id="Types-and-Variables">Types and Variables</h2>

<p>Available data types are strings and numbers (floating point).
Variable names can contain letters (A-Z), digits (0-9) and underscores
(_), but cannot begin with a digit. Reserved keywords cannot be used
as names, but they can contain them, for example:</p>
<p>
Valid: <code>ENDING</code><br/>
Invalid: <code>END</code>
</p>

<p>String variable names must end with a $ symbol, for example:</p>
<pre>NAME$</pre>

<p>Variables are not explicitly declared, but they need to be
initialized with a value before you can read from them. Values are
assigned to variables using the equal symbol:</p>
<pre>
NAME$="LOWRES NX"
LIVES=3
</pre>

<p>Hexadecimal and binary notation can be used for number values:</p>
<pre>
$FF02
%11001011
</pre>

<h2 id="Arrays">Arrays</h2>

<h3 id="_DIM" name="DIM">DIM</h3>

<pre>DIM [GLOBAL] var-list</pre>

<p>Defines arrays with the highest index for each dimension:</p>
<pre>
DIM A(100)
DIM MAP(31,23,1),NAMES$(9),SCORES(9)
</pre>

<p>Access elements from arrays, indices start from 0:</p>
<pre>
SCORES(0)=100
SCORES(9)=5
PRINT SCORES(0),SCORES(9)
</pre>

<p>All elements of arrays are automatically initialized, using zeros
(0) or empty strings ("").</p>

<p>With the optional GLOBAL keyword the arrays will be accessable
from all subprograms.</p>

<h2 id="Labels">Labels</h2>

<p>A label marks a position in a program and is used for commands
like GOTO. It consists of a name, using the same rules as for
variables, followed by a colon:</p>
<pre>
GAMEOVER:
</pre>

<h2 id="Operators">Operators</h2>

<h3 id="Operators-Ari">Arithmetic</h3>

<table>
<tr><th>Symbol</th> <th>Example</th> <th>Purpose</th></tr>
<tr><td>-</td> <td><code>-B</code></td> <td>Negation</td></tr>
<tr><td>^</td> <td><code>X^3</code></td> <td>Exponentiation</td></tr>
<tr><td>*</td> <td><code>2*Y</code></td> <td>Multiplication</td></tr>
<tr><td>/</td> <td><code>X/2</code></td> <td>Division</td></tr>
<tr><td>\</td> <td><code>X\2</code></td> <td>Integer Division</td></tr>
<tr><td>+</td> <td><code>C+2</code></td> <td>Addition</td></tr>
<tr><td>-</td> <td><code>100-D</code></td> <td>Subtraction</td></tr>
<tr><td>MOD</td> <td><code>X&#160;MOD&#160;2</code></td> <td>Modulo</td></tr>
</table>

<p>Operations are performed in mathematical order, for example
multiplications and divisions are performed before additions and
subtractions. The order can be specified explicitly through the use of
parentheses, for example: (3+4*3)/5</p>

<h3 id="Operators-Rel">Relational</h3>

<table>
<tr><th>Symbol</th> <th>Example</th> <th>Purpose</th></tr>
<tr><td>=</td> <td><code>A=10</code></td> <td>Equal</td></tr>
<tr><td>&lt;&gt;</td> <td><code>A&lt;&gt;100</code></td> <td>Not equal</td></tr>
<tr><td>&gt;</td> <td><code>B&gt;C</code></td> <td>Greater than</td></tr>
<tr><td>&lt;</td> <td><code>5&lt;X</code></td> <td>Less than</td></tr>
<tr><td>&gt;=</td> <td><code>X&gt;=20</code></td> <td>Greater than or equal</td></tr>
<tr><td>&lt;=</td> <td><code>X&lt;=30</code></td> <td>Less than or equal</td></tr>
</table>

<p>Relational operator expressions have a value of true (-1) or
false (0). For example: (2=3)=0, (4=4)=-1, (1&lt;3)=-1</p>

<h3 id="Operators-Log">Logical/Bitwise</h3>

<table>
<tr><th>Symbol</th> <th>Example</th> <th>Purpose</th></tr>
<tr><td>NOT</td> <td><code>NOT&#160;(X=15)<br/>NOT&#160;0</code></td> <td>"Not"</td></tr>
<tr><td>AND</td> <td><code>A=1&#160;AND&#160;B=12<br/>170&#160;AND&#160;15</code></td> <td>"And"</td></tr>
<tr><td>OR</td> <td><code>X=10&#160;OR&#160;Y=0<br/>128&#160;OR&#160;2</code></td> <td>"Or"</td></tr>
<tr><td>XOR</td> <td><code>A&#160;XOR&#160;B</code></td> <td>"Exclusive Or"</td></tr>
</table>

<h3 id="Operators-How">How to Use Operators</h3>

<p>All operators are available for numbers. Relational and addition
operators are usable with strings, too:</p>
<pre>
SUM=1+3
IF SUM&lt;5 THEN PRINT "LESS THAN 5"
NAME$="LOWRES NX"
GREET$="HELLO "+NAME$+"!"
IF NAME$&gt;"LOWRES" THEN PRINT GREET$
</pre>


<h1 id="Program-Flow-Control">Program Flow Control</h1>

<h2 id="Basics">Basics</h2>

<h3 id="_REM" name="REM">REM</h3>
<pre>
REM remark
' remark
</pre>

<p>Allows you to put comments into your program. REM lines are not
executed. You can use an apostrophe (') in place of the word REM.</p>


<h3 id="_IF-THEN-ELSE" name="IF,THEN,ELSE">IF...THEN...ELSE</h3>
<pre>
IF expr THEN command [ELSE command]
</pre>

<p>Checks if the given expression is true or false. If it's true, the
command after THEN is executed, otherwise the one after ELSE. The ELSE
part is optional.</p>
<p>If you want to execute more than one command, you can use the
block version of the IF command. It must be closed with the line
END IF.</p>

<pre>
IF expression THEN
    commands
[ELSE IF expression THEN]
    commands
[ELSE]
    commands
END IF
</pre>


<h3 id="_GOTO" name="GOTO">GOTO</h3>

<pre>GOTO label</pre>

<p>Jumps to the given label and continues the program execution there.
</p>


<h3 id="_GOSUB" name="GOSUB">GOSUB</h3>

<pre>GOSUB label</pre>

<p>Adds the current program position to a stack and jumps to the
given label. The program after the label is called a subroutine and
must be finished using RETURN.</p>

<p>NOTE: Subroutines exist mostly for historical reasons. You should
prefer the more powerful and safer subprograms.</p>


<h3 id="_RETURN" name="RETURN">RETURN</h3>

<pre>RETURN</pre>

<p>Jumps back to the position of the last call of GOSUB and removes
it from the stack.</p>

<pre>RETURN label</pre>

<p>Works like GOTO, but clears the whole stack. Use this to exit from
a subroutine, if you want to continue your program somewhere else.</p>


<h3 id="_END" name="END">END</h3>

<pre>END</pre>

<p>Stops the program from any position. The program is also stopped
automatically after the last line of code.</p>


<h3 id="_WAIT-VBL" name="WAIT VBL,WAIT,VBL">WAIT VBL</h3>

<pre>WAIT VBL</pre>

<p>Waits for the next frame. This (or WAIT n) should be the last
command in all loops which do animations and/or handle input,
like the main game loop.</p>


<h3 id="_WAIT" name="WAIT">WAIT</h3>

<pre>WAIT n</pre>

<p>Waits n frames (n/60 seconds).</p>


<h2 id="Loops">Loops</h2>

<h3 id="_FOR-NEXT" name="FOR,TO,STEP,NEXT">FOR...NEXT</h3>
<pre>
FOR var=a TO b [STEP s]
    commands
NEXT var
</pre>

<p>Performs a series of commands in a loop a given number of times.
The FOR command uses the variable var as a counter, starting with the
value a. All commands until NEXT are executed, then the counter is
increased by s (or +1 if STEP is omitted). A check is performed to see
if the counter is now greater than b. If not, the process is repeated.
If it is greater, the program continues with the lines after NEXT. If
STEP s is negative, the loop is executed until the counter is less
than value b.</p>


<h3 id="_DO-LOOP" name="DO,LOOP">DO...LOOP</h3>
<pre>
DO
  commands
LOOP
</pre>

<p>Performs commands in an endless loop. You can use GOTO to exit it.
</p>


<h3 id="_REPEAT-UNTIL" name="REPEAT,UNTIL">REPEAT...UNTIL</h3>
<pre>
REPEAT
    commands
UNTIL expression
</pre>

<p>Executes the commands in a loop until the given expression is true.
The loop is executed at least once.</p>


<h3 id="_WHILE-WEND" name="WHILE,WEND">WHILE...WEND</h3>
<pre>
WHILE expression
    commands
WEND
</pre>

<p>Executes the commands in a loop as long as the given expression is
true.</p>


<h2 id="Subprograms">Subprograms</h2>

<h3 id="_SUB" name="SUB,END SUB,END">SUB...END SUB</h3>
<pre>
SUB name [(parameter-list)]
  commands
END SUB
</pre>

<p>Defines a subprogram with the given name. The optional parameter
list can contain two types of entries: simple variables and array
variables (followed by an empty parentheses pair). Entries are
separated by commas. By default all variables inside the subprogram
are local.</p>

<p>NOTE: Don't use GOTO or GOSUB to jump out of a subprogram!</p>


<h3 id="_CALL" name="CALL">CALL</h3>
<pre>
CALL name [(argument-list)]
</pre>

<p>Executes the subprogram with the given name and returns to the
current position after finishing it. The argument list
must match the parameters of the SUB definition. Simple variables,
single array elements and entire arrays (followed by an empty parentheses pair) are passed by reference to the subprogram. Other
expressions are passed by value.</p>


<h3 id="_EXIT-SUB" name="EXIT SUB,EXIT,SUB">EXIT SUB</h3>
<pre>
EXIT SUB
</pre>

<p>Exits a subprogram before END SUB is reached.</p>


<h3 id="_GLOBAL" name="GLOBAL">GLOBAL</h3>
<pre>
GLOBAL variable-list
</pre>

<p>Makes variables from the main program available to all subprograms.
The list can contain simple variables only. For arrays you should use
DIM GLOBAL. This command cannot be used within a subprogram.</p>


<h1 id="Text">Text</h1>

<h3 id="_PRINT" name="PRINT">PRINT</h3>

<pre>PRINT expression-list</pre>

<p>Outputs text to the current window. Expressions can be strings or
numbers, separated by commas or semicolons. A comma separates the
output with a space, a semicolon outputs without space.
End the list with a comma or semicolon to keep the cursor at the
end of the output, otherwise a new line is started.</p>


<h3 id="_INPUT" name="INPUT">INPUT</h3>

<pre>INPUT ["prompt";]var</pre>

<p>Lets the user enter a text or number on the keyboard and stores it
in the variable var. Optionally it can show a prompt text before
(cannot be a variable).
This enables automatically the keyboard.</p>


<h3 id="_LOCATE" name="LOCATE">LOCATE</h3>

<pre>LOCATE x,y</pre>

<p>Moves the text cursor to column x and row y inside the current
window.</p>


<h3 id="_WINDOW" name="WINDOW">WINDOW</h3>

<pre>WINDOW x,y,w,h,b</pre>

<p>Sets the text output window to cell position x,y and sets the size
to w columns and h rows. Text will be written to background b (0
or 1).</p>

<h3 id="_CLW" name="CLW">CLW</h3>

<pre>CLW</pre>

<p>Clears the window with spaces and resets the text cursor position.
</p>


<h1 id="User-Input">User Input</h1>

<h2 id="Gamepads">Gamepads</h2>

<h3 id="_GAMEPAD" name="GAMEPAD">GAMEPAD</h3>
    
<pre>GAMEPAD n</pre>

<p>Enables gamepads for n players. A maximum of 2 players are
supported. This disables touchscreen/mouse support.</p>

<pre>GAMEPAD OFF</pre>

<p>Disables all gamepads and enables touchscreen/mouse support.</p>


<h3 id="_UP-DOWN-LEFT-RIGHT" name="=UP,DOWN,LEFT,RIGHT">=UP/DOWN/LEFT/RIGHT</h3>

<pre>
UP(p)
DOWN(p)
LEFT(p)
RIGHT(p)
</pre>

<p>Returns true if the given direction is currently pressed on the
direction pad of player p (0/1).</p>

<pre>
UP TAP(p)
DOWN TAP(p)
LEFT TAP(p)
RIGHT TAP(p)
</pre>

<p>With the optional TAP keyword, this function returns true only for
the first frame the button is pressed.</p>


<h3 id="_BUTTON" name="BUTTON,TAP">=BUTTON</h3>

<pre>BUTTON(p,n)</pre>

<p>Returns true if button A (n=0) or B (n=1) is currently pressed by
player p (0/1).</p>

<pre>BUTTON TAP(p,n)</pre>

<p>With the optional TAP keyword, this function returns true only for
the first frame the button is pressed.</p>


<h3 id="_PAUSE-ON-OFF" name="PAUSE ON,PAUSE OFF,PAUSE,ON,OFF">PAUSE ON/OFF</h3>

<pre>
PAUSE ON
PAUSE OFF
</pre>

<p>Enables or disables the automatic pause handling. By default it's
enabled, so if you press the pause button, the program stops and
shows "PAUSE" on the screen, until the button is pressed again.</p>


<h3 id="_PAUSE" name="PAUSE">PAUSE</h3>

<pre>
PAUSE
</pre>

<p>Pauses the program and shows the default "PAUSE" screen, even if
automatic pause handling is disabled.</p>


<h3 id="_=PAUSE" name="PAUSE">=PAUSE</h3>

<pre>
PAUSE
</pre>

<p>Returns true if the pause button was pressed, otherwise false.
After calling this function its value is cleared, so it returns
each button tap only once. The automatic pause handling needs to
be disabled for this function.</p>


<h2 id="Touch">Touch</h2>

<p>Use touch support only if you think it will work well with a
computer mouse, too. If you want to create your own game buttons,
keep in mind that your game might be unplayable on a computer,
because it won't support the keyboard or a real gamepad. Always
consider using the standard gamepad functions.</p>


<h3 id="_TOUCH.X-TOUCH.Y" name="TOUCH.X,TOUCH.Y">=TOUCH.X/Y</h3>
<pre>
TOUCH.X
TOUCH.Y
</pre>

<p>Returns the current X or Y pixel position where the user touches
the screen, or where it was touched the last time.</p>


<h3 id="_TOUCH" name="TOUCH">=TOUCH</h3>

<pre>TOUCH</pre>

<p>Returns true if the screen is currently touched.</p>


<h3 id="_TAP" name="TAP">=TAP</h3>

<pre>TAP</pre>

<p>Returns true if the screen is currently touched and was not
touched the last frame.</p>


<h2 id="Keyboard">Keyboard</h2>

<h3 id="_KEYBOARD-ON-OFF" name="KEYBOARD ON,KEYBOARD OFF,KEYBOARD,ON,OFF">KEYBOARD ON/OFF</h3>

<pre>
KEYBOARD ON
KEYBOARD OFF
</pre>

<p>Enables or disables the keyboard.</p>


<h3 id="_INKEY$" name="INKEY$">=INKEY$</h3>

<pre>INKEY$</pre>

<p>Returns the last pressed key as a string. If no key was pressed,
it returns an empty string (""). After calling this function its
value is cleared, so it returns each pressed key only once.
The keyboard needs to be enabled for this function.</p>


<h1 id="Graphics">Graphics</h1>

<p>All graphics in LowRes NX are based on characters. A character is an
8x8-pixel image with 3 colors plus transparent. They are usually
designed in black and white, but are displayed with one of the 8
programmable color palettes.</p>

<p>At program start all characters from ROM entry 2 are copied to
video RAM to make them immediately usable.</p>

<p>The display is composed of 3 layers, which are from back to front:</p>
<ul>
<li>Background 1 (BG 1)</li>
<li>Background 0 (BG 0)</li>
<li>Sprites</li>
</ul>

<p>Each sprite and background cell has an attribute called "priority".
By setting it, the cell or sprite will appear on a higher display
layer. Actually there are 6 layers, from back to front:</p>
<ul>
<li>Background 1 (BG 1) - prio 0</li>
<li>Background 0 (BG 0) - prio 0</li>
<li>Sprites - prio 0</li>
<li>Background 1 (BG 1) - prio 1</li>
<li>Background 0 (BG 0) - prio 1</li>
<li>Sprites - prio 1</li>
</ul>


<h2 id="Sprites">Sprites</h2>

<p>Sprites are independent objects, which can be freely moved on the
screen. They can have a size of 8x8 pixels (one character) or up to
32x32 pixels by grouping several characters. Each sprite has the
standard character attributes (color palette, flip X/Y, priority) and additionally its size.</p>


<h3 id="_SPRITE" name="SPRITE">SPRITE</h3>

<pre>SPRITE n,x,y,c</pre>

<p>Sets the position (x,y) and character (c) of sprite n (0-63).
All parameters can be omitted to keep their current settings.</p>


<h3 id="_SPRITE-OFF" name="SPRITE OFF,SPRITE,OFF">SPRITE OFF</h3>

<pre>
SPRITE OFF [n]
SPRITE OFF a TO b
</pre>

<p>Hides one or more sprites. If all parameters are omitted, all sprites (0 - 63) are hidden. With one parameter only the given sprite is hidden. The last option is to hide sprites in the range from a to b.</p>


<h3 id="_SPRITE.A" name="SPRITE.A">SPRITE.A</h3>

<pre>SPRITE.A n,(pal,fx,fy,pri,s)</pre>

<p>Sets the attributes of sprite n (0-63). All attribute parameters
can be omitted to keep their current settings.</p>

<table>
<tr><td>pal</td> <td>palette number (0-7)</td></tr>
<tr><td>fx</td> <td>flip horizontally (0/1)</td></tr>
<tr><td>fy</td> <td>flip vertically (0/1)</td></tr>
<tr><td>pri</td> <td>priority flag (0/1)</td></tr>
<tr><td>s</td> <td>size (0-3):<br/>
0: 1 character (8x8 px)<br/>
1: 2x2 characters (16x16 px)<br/>
2: 3x3 characters (24x24 px)<br/>
3: 4x4 characters (32x32 px)</td></tr>
</table>

<pre>SPRITE.A n,a</pre>

<p>Allows setting the attributes as a single 8-bit value.</p>


<h3 id="_=SPRITE.X-Y" name="SPRITE.X,SPRITE.Y">=SPRITE.X/Y</h3>

<pre>
SPRITE.X(n)
SPRITE.Y(n)
</pre>

<p>Return the position of sprite n.</p>


<h3 id="_=SPRITE.C" name="SPRITE.C">=SPRITE.C</h3>

<pre>SPRITE.C(n)</pre>

<p>Returns the character of sprite n.</p>


<h3 id="_=SPRITE.A" name="SPRITE.A">=SPRITE.A</h3>

<pre>SPRITE.A(n)</pre>

<p>Returns the attributes of sprite n as an 8-bit value.</p>


<h3 id="_=SPRITE-HIT" name="SPRITE HIT,SPRITE,HIT">=SPRITE HIT</h3>

<pre>SPRITE HIT(n[,a [TO b]])</pre>

<p>Returns true if sprite n collides with another sprite (which means
that pixels overlap). If no more parameters are given, it will
check with all other visible sprites. If the a parameter is added,
it will check only with that sprite a. If all parameters are
given, it will check with all sprites from number a to number b.</p>


<h3 id="_=HIT" name="HIT">=HIT</h3>

<pre>HIT</pre>

<p>Returns the number of the sprite which collided with the sprite of
the last call of SPRITE HIT.</p>


<h2 id="Backgrounds">Backgrounds</h2>

<p>A background is a map of 32x32 character cells, which is used for text
and tile based maps or images. Each cell has the information of which
character it contains and additional attributes (color palette, flip
X/Y, priority).<br/>
As a character has the size of 8x8 pixels, the resulting background
size is 256x256 pixels, which is larger than the actual screen
(160x128). By modifying the scroll offset of a background, the visible
area can be moved.<br/>
If the visible area moves out of the borders of the background, the
display wraps around the edges. This can be used to achieve endless
scrolling.<br/>
There is a mode for 16x16-pixel cells. When active, each cell will show
2x2 characters, similar to big sprites. This mode also increases the
background size to 512x512 pixels. Use the DISPLAY command to enable
it.</p>


<h3 id="_CLS" name="CLS">CLS</h3>
    
<pre>CLS</pre>

<p>Clears both backgrounds with character 0 and resets the current
window to the default one.</p>

<pre>CLS b</pre>

<p>Clears background b with character 0.</p>


<h3 id="_ATTR" name="ATTR">ATTR</h3>

<pre>ATTR (pal,fx,fy,pri,s)[,m]</pre>

<p>Sets the current attributes for cell and text commands.
All attribute parameters can be omitted to keep their current
settings.</p>

<table>
<tr><td>pal</td> <td>palette number (0-7)</td></tr>
<tr><td>fx</td> <td>flip horizontally (0/1)</td></tr>
<tr><td>fy</td> <td>flip vertically (0/1)</td></tr>
<tr><td>pri</td> <td>priority flag (0/1)</td></tr>
<tr><td>s</td> <td>unused (0-3)</td></tr>
</table>

<p>The optional parameter m is an 8-bit binary number used as a mask.
It defines which bits of a cell attribute should actually be changed.</p>


<pre>ATTR a[,m]</pre>

<p>Allows setting the attributes as a single 8-bit value.</p>


<h3 id="_BG" name="BG">BG</h3>

<pre>BG n</pre>

<p>Sets the current background (0 or 1).</p>


<h3 id="_CELL" name="CELL">CELL</h3>

<pre>CELL x,y,[c]</pre>

<p>Sets the cell at position x,y of the current background to
character c. If c is omitted, only the attributes of the cell get
changed.</p>


<h3 id="_CELL.C" name="CELL.C">=CELL.C</h3>

<pre>CELL.C(x,y)</pre>

<p>Returns the character of the cell at position x,y of the current
background.</p>


<h3 id="_CELL.A" name="CELL.A">=CELL.A</h3>

<pre>CELL.A(x,y)</pre>

<p>Returns the attributes of the cell at position x,y of the current
background as an 8-bit value.</p>


<h3 id="_BG-FILL" name="BG FILL,BG,FILL,TO,CHAR">BG FILL</h3>

<pre>BG FILL x1,y1 TO x2,y2 [CHAR c]</pre>

<p>Sets all cells in the area from x1,y1 to x2,y2 of the current
background to character c. If CHAR c is omitted, only the attributes
of the cells get changed.</p>


<h3 id="_BG-SOURCE" name="BG SOURCE,BG,SOURCE">BG SOURCE</h3>

<pre>BG SOURCE a[,w]</pre>

<p>Sets the current source for the BG COPY command. The two-
dimensional map starts at memory address "a" and has a width of w
cells.</p>

<p>Without the width parameter, Background Designer's data
format is assumed: The width is read from address a+2 and
the actual map data starts at a+4.</p>

<p>By default ROM entry 3 is used as source.</p>


<h3 id="_BG-COPY" name="BG COPY,BG,COPY">BG COPY</h3>

<pre>BG COPY x1,y1,w,h TO x2,y2</pre>

<p>Copies a two-dimensional part of the current source to the
current background. The destination co-ordinates can be outside of
the background size (32x32), but they will be wrapped around the
edges (32->0, 33->1, etc.).</p>


<h3 id="_BG-SCROLL" name="BG SCROLL,BG,SCROLL,STEP">BG SCROLL</h3>

<pre>BG SCROLL x1,y1 TO x2,y2 STEP dx,dy</pre>

<p>Moves the content of all cells in the area from x1,y1 to x2,y2
horizontally by dx and vertically by dy cells.</p>


<h3 id="_TEXT" name="TEXT">TEXT</h3>

<pre>TEXT x,y,s$</pre>

<p>Outputs the string s$ to the current background at cell position
x,y.</p>


<h3 id="_NUMBER" name="NUMBER">NUMBER</h3>

<pre>NUMBER x,y,n,d</pre>

<p>Outputs the number n to the current background at cell position
x,y. The number is formatted to show always d digits.
This command is preferred over TEXT to show numbers, as it
doesn't need to convert numbers to strings.</p>


<h3 id="_FONT" name="FONT">FONT</h3>
    
<pre>FONT c</pre>

<p>Sets the current character range used for text output.
c is the character where the font starts (space).</p>

<p>The default value is 192, which points to the standard font,
if available.</p>


<h3 id="_SCROLL" name="SCROLL">SCROLL</h3>

<pre>SCROLL b,x,y</pre>

<p>Sets the scroll offset of background b (0/1) to pixel
co-ordinates x,y.</p>


<h3 id="_SCROLL.X-SCROLL.Y" name="SCROLL.X,SCROLL.Y">=SCROLL.X/Y</h3>

<pre>
SCROLL.X(b)
SCROLL.Y(b)
</pre>

<p>Return the scroll offset of background b.</p>


<h2 id="Display-Settings">Display Settings</h2>

<h3 id="_DISPLAY" name="DISPLAY">DISPLAY</h3>

<pre>DISPLAY (s,b0,b1,c0,c1)</pre>

<p>Sets the display attributes. All attribute parameters can be omitted to keep their current settings.</p>

<table>
<tr><td>s</td> <td>sprites enabled (0/1)</td></tr>
<tr><td>b0</td> <td>background 0 enabled (0/1)</td></tr>
<tr><td>b1</td> <td>background 1 enabled (0/1)</td></tr>
<tr><td>c0</td> <td>BG 0 cell size,</td></tr>
<tr><td>c1</td> <td>BG 1 cell size:<br/> 
0: 1 character (8x8 pixels)<br/>
1: 2x2 characters (16x16 pixels)</td></tr>
</table>

<pre>DISPLAY a</pre>

<p>Allows setting the attributes as a single 8-bit value.</p>


<h3 id="_=DISPLAY" name="DISPLAY">=DISPLAY</h3>

<pre>DISPLAY</pre>

<p>Returns the display attributes as an 8-bit value.</p>


<h3 id="_PALETTE" name="PALETTE">PALETTE</h3>

<pre>PALETTE n,c0,c1,c2,c3</pre>

<p>Sets all four colors of palette n (0-7). Color 0 is only used for
palette 0 and shown as the screen's backdrop color. The color
parameters can be omitted to keep their current settings.
Valid color values are 0-63 and can be calculated like this:</p>
<pre>
VALUE = RED * 16 + GREEN * 4 + BLUE
</pre>
<p>RED, GREEN and BLUE are values from 0 to 3.</p>

<p>By default all palettes are read from ROM entry 1.</p>


<h3 id="_=COLOR" name="COLOR">=COLOR</h3>

<pre>COLOR(p,n)</pre>

<p>Returns the value of color n (0-3) from palette p (0-7).
You can get the RED, GREEN and BLUE values like this:</p>
<pre>
RED = INT(VALUE / 16)
GREEN = INT(VALUE / 4) MOD 4
BLUE = VALUE MOD 4
</pre>


<h3 id="_ON-RASTER-CALL" name="ON RASTER CALL,ON RASTER,RASTER CALL,ON,RASTER,CALL,ON RASTER OFF,RASTER OFF,OFF">ON RASTER CALL/OFF</h3>

<pre>ON RASTER CALL name</pre>

<p>Sets a subprogram which is executed for every screen line before
it's drawn. Usually used to change color palettes or scroll
offsets to achieve graphical effects. Raster subprograms must be
short.</p>

<pre>ON RASTER OFF</pre>

<p>Removes the current subprogram.</p>


<h3 id="_=RASTER" name="RASTER">=RASTER</h3>

<pre>RASTER</pre>

<p>Returns the current screen line (y position). Use this in a raster
subprogram.</p>


<h3 id="_ON-VBL-CALL" name="ON VBL CALL,ON VBL,VBL CALL,ON,VBL,CALL,ON VBL OFF,VBL OFF,OFF">ON VBL CALL/OFF</h3>

<pre>ON VBL CALL name</pre>

<p>Sets a subprogram which is executed after each frame. Can be used
to update animations or sounds, even if the main program is
blocked by WAIT or INPUT.</p>

<pre>ON VBL OFF</pre>

<p>Removes the current subprogram.</p>


<h3 id="_=TIMER" name="TIMER">=TIMER</h3>

<pre>TIMER</pre>

<p>Returns the number of frames shown since LowRes NX was started.
The value wraps to 0 when 5184000 is reached, which is about 24
hours.</p>


<h1 id="Sound">Sound</h1>

<p>LowRes NX has four independent sound generators (voices). Each one
can play sawtooth, triangle, pulse and noise waveforms, and has
frequency, volume and pulse width settings. An additional envelope
generator and LFO per voice makes complex sounds and instruments
possible.</p>
<p>You can use the tool "Sound Composer" (or compatible programs) to
create music, tracks and sound presets.</p>


<h3 id="_MUSIC" name="MUSIC">MUSIC</h3>

<pre>MUSIC [p]</pre>

<p>Starts playback of a song at pattern p. If the parameter p is
omitted, it starts at pattern 0.</p>


<h3 id="_TRACK" name="TRACK">TRACK</h3>

<pre>TRACK n,v</pre>

<p>Plays track n once on voice v. Each voice can play a track
independently, so this can be used for sound effects, even while music
is playing.</p>


<h3 id="_PLAY" name="PLAY">PLAY</h3>

<pre>PLAY v,p[,l] [SOUND s]</pre>

<p>Plays a sound on voice v (0-3). p is the pitch:</p>
<table>
    <tr><th>Note</th><th colspan="8">Pitch (with different octaves)</th></tr>
    <tr><th>C</th><td>1</td><td>13</td><td>25</td><td>37</td><td>49</td><td>61</td><td>73</td><td>85</td></tr>
    <tr><th>C#</th><td>2</td><td>14</td><td>26</td><td>38</td><td>50</td><td>62</td><td>74</td><td>86</td></tr>
    <tr><th>D</th><td>3</td><td>15</td><td>27</td><td>39</td><td>51</td><td>63</td><td>75</td><td>87</td></tr>
    <tr><th>D#</th><td>4</td><td>16</td><td>28</td><td>40</td><td>52</td><td>64</td><td>76</td><td>88</td></tr>
    <tr><th>E</th><td>5</td><td>17</td><td>29</td><td>41</td><td>53</td><td>65</td><td>77</td><td>89</td></tr>
    <tr><th>F</th><td>6</td><td>18</td><td>30</td><td>42</td><td>54</td><td>66</td><td>78</td><td>90</td></tr>
    <tr><th>F#</th><td>7</td><td>19</td><td>31</td><td>43</td><td>55</td><td>67</td><td>79</td><td>91</td></tr>
    <tr><th>G</th><td>8</td><td>20</td><td>32</td><td>44</td><td>56</td><td>68</td><td>80</td><td>92</td></tr>
    <tr><th>G#</th><td>9</td><td>21</td><td>33</td><td>45</td><td>57</td><td>69</td><td>81</td><td>93</td></tr>
    <tr><th>A</th><td>10</td><td>22</td><td>34</td><td>46</td><td>58</td><td>70</td><td>82</td><td>94</td></tr>
    <tr><th>A#</th><td>11</td><td>23</td><td>35</td><td>47</td><td>59</td><td>71</td><td>83</td><td>95</td></tr>
    <tr><th>B</th><td>12</td><td>24</td><td>36</td><td>48</td><td>60</td><td>72</td><td>84</td><td>96</td></tr>
</table>

<p>The optional parameter l is the length in 1/60 seconds, the maximum
is 255. 0 means, that the the sound won't stop automatically. If the
parameter is omitted, the current value of the voice is kept.</p>

<p>By default the current sound settings of the voice are used. Add
the SOUND parameter to use the sound number s from the Sound Composer
tool.</p>


<h3 id="_STOP" name="STOP">STOP</h3>

<pre>STOP [v]</pre>

<p>Stops the current sound and track on voice v. If the parameter is
omitted, all voices, tracks and music are stopped. If a voice's
envelope has a release time, the sound won't stop immediately, but
fade out.</p>


<h3 id="_VOLUME" name="VOLUME">VOLUME</h3>

<pre>VOLUME v,vol,mix</pre>

<p>Sets the volume of voice n (0-3) to vol (0-15) and its outputs to
mix (0-3):</p>

<table>
<tr><td>0</td><td>Muted</td></tr>
<tr><td>1</td><td>Left</td></tr>
<tr><td>2</td><td>Right</td></tr>
<tr><td>3</td><td>Left and right (center)</td></tr>
</table>

<p>All parameters can be omitted to keep their current settings.</p>


<h3 id="_SOUND" name="SOUND">SOUND</h3>

<pre>SOUND v,w,pw,l</pre>

<p>Sets the basic sound parameters of voice v (0-3).</p>
<p>w is the waveform:</p>

<table>
<tr><td>0</td><td>Sawtooth</td></tr>
<tr><td>1</td><td>Triangle</td></tr>
<tr><td>2</td><td>Pulse</td></tr>
<tr><td>3</td><td>Noise</td></tr>
</table>

<p>pw is the pulse width (0-15), a value of 8 results in a square
wave. This parameter only has an effect for the pulse waveform.</p>
<p>l is the sound length in 1/60 seconds, the maximum is 255. 0 means,
that the sound won't stop automatically. If the length is set using
this command, the length parameter of PLAY can be omitted.</p>
<p>All parameters can be omitted to keep their current settings.</p>


<h3 id="_ENVELOPE" name="ENVELOPE">ENVELOPE</h3>

<pre>ENVELOPE v,a,d,s,r</pre>

<p>Sets the volume envelope generator of voice v (0-3).</p>
<p>a is the attack time, d is the decay time, and r is the release
time. All times are non-linear and range from 0 (2 ms) to 15 (12 s)</p>
<p>s is the sustain level (0-15), which is the volume after the decay
time and before the sound gets released.</p>
<p>All parameters can be omitted to keep their current settings.</p>


<h3 id="_LFO" name="LFO">LFO</h3>

<pre>LFO v,r,fr,vol,pw</pre>

<p>Sets the LFO (low frequency oscillator) of voice v (0-3).</p>
<p>r is the LFO rate and ranges from 0 (0.12 Hz) to 15 (18 Hz) in a
non-linear manner.</p>
<p>The other paramters set the amount of the effect on different sound
parameters: fr for frequency/pitch, vol for volume and pw for pulse
width. These values range from 0 to 15.</p>
<p>All parameters can be omitted to keep their current settings.</p>


<h3 id="_LFO.A" name="LFO.A">LFO.A</h3>

<pre>LFO.A v,(w,r,e,t)</pre>

<p>Sets additional LFO attributes of voice v (0-3).
All attribute parameters can be omitted to keep their current settings.</p>

<table>
<tr><td>w</td> <td>wave (0-3):<br/>
0: triangle<br/>
1: sawtooth<br/>
2: square<br/>
3: random</td></tr>
<tr><td>r</td> <td>revert (0/1)</td></tr>
<tr><td>e</td> <td>env mode enabled (0/1)</td></tr>
<tr><td>t</td> <td>trigger enabled (0/1)</td></tr>
</table>

<p>By default the LFO adds its output to the normal sound parameters.
If revert is enabled, it subtracts.
By enabling the env mode, the LFO stops after one cycle, so it can
be used as an additional envelope generator. If the trigger is
enabled, the LFO restarts for each played sound, otherwise it runs
continuously. Trigger is enabled implicitly with the env mode.</p>


<h3 id="_SOUND-SOURCE" name="SOUND SOURCE,SOUND,SOURCE">SOUND SOURCE</h3>

<pre>SOUND SOURCE a</pre>

<p>Sets the current data source for the PLAY, MUSIC and TRACK
commands to the memory address "a". This only affects the following
calls to these commands, already started playback keeps its own data
source. The data is assumed to be in the format of the Sound Composer
tool.</p>

<p>By default ROM entry 15 is used as source.</p>


<h1 id="Data">Data</h1>

<h3 id="_DATA" name="DATA">DATA</h3>

<pre>DATA constant-list</pre>

<p>Stores comma separated numeric and string constants (values, but
no variables or expressions) that are accessed by the READ
command. DATA commands are not executed and may be placed
anywhere in the program.</p>
<p>READ commands access DATA in order, from the top of a program
until the bottom. All constants of all DATA commands are read as
one continuous list of items.</p>


<h3 id="_READ" name="READ">READ</h3>

<pre>READ var-list</pre>

<p>Reads values from DATA commands and assigns them to the
comma separated variables in var-list. The program has an internal
pointer to the current DATA value. With each value read, the
pointer will move to the next DATA value.</p>


<h3 id="_RESTORE" name="RESTORE">RESTORE</h3>

<pre>RESTORE [label]</pre>

<p>Changes the internal read pointer to another position. This allows
to reread data or to select specific data. If the label parameter
is omitted, READ will start again from the top of the program.
Otherwise the pointer will be set to the jump label.</p>


<h1 id="Memory-Access">Memory Access</h1>

<h3 id="_=PEEK" name="PEEK">=PEEK</h3>

<pre>PEEK(a)</pre>

<p>Returns the current 8-bit value (0-255) at memory address a.</p>


<h3 id="_POKE" name="POKE">POKE</h3>

<pre>POKE a,v</pre>

<p>Sets the memory at address a to value v. v can be any integer
number, but only the lowest 8 bits are written to memory.</p>


<h3 id="_COPY" name="COPY">COPY</h3>

<pre>COPY a,n TO d</pre>

<p>Copies n bytes starting from memory address a to address d.
The source and the destination areas may overlap.</p>


<h3 id="_FILL" name="FILL">FILL</h3>

<pre>FILL a,n[,v]</pre>

<p>Sets n bytes starting from memory address a to value v, or 0 if
the parameter is omitted.</p>


<h3 id="_=ROM" name="ROM">=ROM</h3>

<pre>ROM(n)</pre>

<p>Returns the memory address of ROM entry n.</p>


<h3 id="_=SIZE" name="SIZE">=SIZE</h3>

<pre>SIZE(n)</pre>

<p>Returns the number of bytes of ROM entry n.</p>


<h1 id="Files">Files</h1>

<p>The file commands can be used to store data on a
virtual disk, which can contain up to 16 files. Its format is the same
as the ROM entries part in a program file. This makes it possible to
use any NX program directly as a virtual disk to edit its data.</p>

<p>Virtual disks are meant to be used for development tools only, for
example image and map editors or music programs. Games should use
persistent memory instead. Imagine that the standard LowRes NX console
wouldn't have a disk drive.</p>


<h3 id="_LOAD" name="LOAD">LOAD</h3>

<pre>LOAD f,a</pre>

<p>Loads the file number f from the current virtual disk to memory starting
at address a.</p>

<p>LOAD is meant to be used for tools only. Use ROM entries for game
data.</p>


<h3 id="_SAVE" name="SAVE">SAVE</h3>

<pre>SAVE f,c$,a,n</pre>

<p>Saves n bytes starting at memory address a to the current virtual
disk as a file number f (0-15) with comment c$ (up to 31 characters).</p>

<p>If this file was loaded before, consider keeping its original comment or
allow the user to edit it before saving. If the file is new, the comment
should contain at least the type of data, e.g. "CHARACTERS" or "MUSIC".</p>

<p>SAVE is meant to be used for tools only. Use persistent memory to
store game states.</p>


<h3 id="_FILES" name="FILES">FILES</h3>

<pre>FILES</pre>

<p>Loads the current file directory for use with FILES$.</p>


<h3 id="_FILE" name="FILE$">=FILE$</h3>

<pre>FILE$(f)</pre>

<p>Returns the comment string of file number f. Call FILES before accessing the file directory to update its content, or use FILE$ directly after LOAD or SAVE.</p>


<h3 id="_=FSIZE" name="FSIZE">=FSIZE</h3>

<pre>FSIZE(n)</pre>

<p>Returns the number of bytes of file number n. Call FILES before accessing the file directory to update its content, or use FSIZE directly after LOAD or SAVE.</p>


<h1 id="Debugging">Debugging</h1>

<h3 id="_TRACE" name="TRACE">TRACE</h3>

<pre>TRACE expression-list</pre>

<p>Outputs text to the debugging window. Expressions can be strings or
numbers, separated by commas. This command is ignored if the debugging
mode is not enabled.</p>


<h1 id="Math-Functions">Math Functions</h1>

<h2 id="Trigonometric">Trigonometric</h2>

<h3 id="_PI" name="PI">=PI</h3>

<pre>PI</pre>

<p>PI is the ratio of the circumference of a circle to its diameter:
3.1415926535...</p>


<h3 id="_SIN" name="SIN">=SIN</h3>

<pre>SIN(x)</pre>

<p>The sine of x, where x is in radians.</p>


<h3 id="_COS" name="COS">=COS</h3>

<pre>COS(x)</pre>

<p>The cosine of x, where x is in radians.</p>


<h3 id="_TAN" name="TAN">=TAN</h3>

<pre>TAN(x)</pre>

<p>The tangent of x, where x is in radians.</p>


<h3 id="_ATN" name="ATN">=ATN</h3>

<pre>ATN(x)</pre>

<p>The arctangent of x in radians, i.e. the angle whose tangent is x.
The range of the function is -(PI/2) &lt; ATN(X) &lt; (PI/2).</p>


<h2 id="Standard-Math">Standard Math</h2>

<h3 id="_ABS" name="ABS">=ABS</h3>

<pre>ABS(x)</pre>

<p>The absolute value of x.</p>


<h3 id="_SGN" name="SGN">=SGN</h3>

<pre>SGN(x)</pre>

<p>The sign of x: -1 if x &lt; 0, 0 if x = 0 and +1 if x &gt; 0.</p>


<h3 id="_INT" name="INT">=INT</h3>

<pre>INT(x)</pre>

<p>The largest integer not greater than x; e.g. INT(1.3) = 1 and
INT(-1.3) = -2.</p>


<h3 id="_EXP" name="EXP">=EXP</h3>

<pre>EXP(x)</pre>

<p>The exponential of x, i.e. the value of the base of natural
logarithms (e = 2,71828...) raised to the power x.</p>


<h3 id="_LOG" name="LOG">=LOG</h3>

<pre>LOG(x)</pre>

<p>The natural logarithm of x; x must be greater than zero.</p>


<h3 id="_SQR" name="SQR">=SQR</h3>

<pre>SQR(x)</pre>

<p>The nonnegative square root of x; x must be nonnegative.</p>


<h2 id="Random-Sequences">Random Sequences</h2>

<h3 id="_RND" name="RND">=RND</h3>

<pre>RND</pre>

<p>The next number in a sequence of random numbers uniformly
distributed in the range 0 &lt;= RND &lt; 1.</p>


<h3 id="_RANDOMIZE" name="RANDOMIZE,TIMER">RANDOMIZE</h3>
<pre>RANDOMIZE x</pre>

<p>Sets the seed for random numbers to x, which should be an integer
value. By default a program starts with seed 0, so the sequence of
random numbers is always the same.</p>

<pre>RANDOMIZE TIMER</pre>

<p>If you want different random numbers each time you run your
program, you should insert this line at the beginning.</p>


<h2 id="Manipulating-Numbers">Manipulating Numbers</h2>

<h3 id="_MIN" name="MIN">=MIN</h3>

<pre>MIN(x,y)</pre>

<p>The MIN function returns the smallest value of two expressions.</p>


<h3 id="_MAX" name="MAX">=MAX</h3>

<pre>MAX(x,y)</pre>

<p>The MAX function returns the largest value of two expressions.</p>


<h3 id="_SWAP" name="SWAP">SWAP</h3>

<pre>SWAP var1,var2</pre>

<p>Swaps the data between any two variables of the same type.</p>


<h1 id="String-Functions">String Functions</h1>

<h3 id="_LEFT$" name="LEFT$">=LEFT$=</h3>

<pre>LEFT$(s$,n)</pre>

<p>Returns a new string with the first n characters of s$.</p>

<pre>LEFT$(s$,n)=a$</pre>

<p>Overwrites the first characters in the variable s$ with the first
n characters of a$.</p>


<h3 id="_RIGHT$" name="RIGHT$">=RIGHT$=</h3>

<pre>RIGHT$(s$,n)</pre>

<p>Returns a new string with the last n characters of s$.</p>

<pre>RIGHT$(s$,n)=a$</pre>

<p>Overwrites the last characters in the variable s$ with the last n
characters of a$.</p>


<h3 id="_MID$" name="MID$">=MID$=</h3>

<pre>MID$(s$,p,n)</pre>

<p>Returns a new string with n characters of s$, starting at
character p. The first character has the position 1.</p>

<pre>MID$(s$,p,n)=a$</pre>

<p>Overwrites the given text range in the variable s$ with the first
n characters of a$.</p>


<h3 id="_INSTR" name="INSTR">=INSTR</h3>

<pre>INSTR(d$,s$[,p])</pre>

<p>Searches the first occurrence of s$ inside of d$ and returns its
start position. If it's not found, the function returns 0.
Usually the function starts searching at the beginning of the
string. Optionally it can start searching at position p.</p>


<h3 id="_CHR$" name="CHR$">=CHR$</h3>

<pre>CHR$(n)</pre>

<p>Returns a string containing one character with ASCII code n.</p>


<h3 id="_ASC" name="ASC">=ASC</h3>

<pre>ASC(a$)</pre>

<p>Supplies you with the ASCII code of the first character of a$.</p>


<h3 id="_LEN" name="LEN">=LEN</h3>

<pre>LEN(a$)</pre>

<p>Returns the number of characters in a$.</p>


<h3 id="_VAL" name="VAL">=VAL</h3>

<pre>VAL(a$)</pre>

<p>Converts a number written in a$ into a numeric value.</p>


<h3 id="_STR$" name="STR$">=STR$</h3>

<pre>STR$(n)</pre>

<p>Converts the number n into a string.</p>


<h3 id="_BIN$" name="BIN$">=BIN$</h3>

<pre>BIN$(n)</pre>

<p>Converts the number n into a binary string.</p>


<h3 id="_HEX$" name="HEX$">=HEX$</h3>

<pre>HEX$(n)</pre>

<p>Converts the number n into a hexadecimal string.</p>


<h1 id="Advanced-Topics">Advanced Topics</h1>

<h2 id="CPU-Cycles">CPU Cycles</h2>

<p>LowRes NX has a simplified simulation of CPU cycles. There is a
fixed limit of cycles per frame. This assures the same program
execution speed on all devices, so if you optimize your program on
your device to run smoothly, it will run the same on all other
devices.</p>

<p>Each execution of a command, function or operator, as well as
access to a variable or a constant count 1 cycle. Some operations have
additional costs:</p>
<ul>
<li>String creation and modification count 1 cycle per letter.</li>
<li>Array initialization counts 1 cycle per element.</li>
<li>Memory area modification counts 1 cycle per byte (not single byte
modifications like POKE).</li>
<li>BG area modification and text output count 2 cycles per cell (not
single cell modifications like CELL).</li>
</ul>

<table>
<tr><td>Total cycles per frame</td><td>17556</td></tr>
<tr><td>Cycles per VBL interrupt</td><td>1140</td></tr>
<tr><td>Cycles per raster interrupt</td><td>51</td></tr>
</table>

<p>The main program may spend any number of cycles, but when the limit
is reached before a WAIT VBL or WAIT command, the execution continues
in the next frame. Interrupts have hard limits. If they are exceeded,
the program stops with an error.</p>


<h2 id="Hardware-Reference">Hardware Reference</h2>

<h3 id="Memory-Map">Memory Map</h3>

<pre>
$0000 - Cartridge ROM (32 KB)

$8000 - Character Data (4 KB)
$9000 - BG0 Data (2 KB)
$9800 - BG1 Data (2 KB)

$A000 - Working RAM (16 KB)

$E000 - Persistent RAM (256 B)
        (not available yet)

$FE00 - Sprite Registers (256 B)
$FF00 - Color Registers (32 B)
$FF20 - Video Registers
$FF40 - Audio Registers
$FF70 - I/O Registers
</pre>

<h3 id="Character-Data">Character Data</h3>

<p>A character is an 8x8-pixel image with 2 bits per pixel, with a
resulting size of 16 bytes. The video RAM has space for 256
characters.</p>

<p>The first 8 bytes of a character contain the low bits of all its
pixels, followed by 8 more bytes containing the high bits of all
pixels.</p>

<h3 id="BG-Data">BG Data</h3>

<p>A background is a map of 32x32 character cells. Each cell occupies two
bytes:</p>
<pre>
- Character number
- Attributes:
    Bit  Purpose
    0-2  Palette number
    3    Flip X
    4    Flip Y
    5    Priority
    6-7  Unused
</pre>

<h3 id="Sprite-Registers">Sprite Registers</h3>

<p>There are 64 sprites available, each occupies 4 bytes:</p>
<pre>
- X position
- Y position
- Character number
- Attributes:
    Bit  Purpose
    0-2  Palette number
    3    Flip X
    4    Flip Y
    5    Priority
    6-7  Size:
         0: 1 character (8x8 px)
         1: 2x2 characters (16x16 px)
         2: 3x3 characters (24x24 px)
         3: 4x4 characters (32x32 px)
</pre>
<p>Note: X and Y sprite position registers have an offset of 32,
so they can move out of the top/left screen borders without using
negative numbers. Using the BASIC commands, this offset is
removed for convenience.</p>

<h3 id="Color-Registers">Color Registers</h3>

<p>There are 8 palettes of each 4 colors. One color is one byte:</p>
<pre>
Bits  Component
0-1   Blue
2-3   Green
4-5   Red
</pre>

<h3 id="Video-Registers">Video Registers</h3>

<pre>
$FF20 - Attributes:
    Bit  Purpose
    0    Sprites enabled
    1    BG0 enabled
    2    BG1 enabled
    3    BG0 cell size,
    4    BG1 cell size:
         0: 1 character (8x8 px)
            (BG 256x256 px)
         1: 2x2 characters (16x16 px)
            (BG 512x512 px)

$FF21 - BG0 scroll offset X
$FF22 - BG0 scroll offset Y
$FF23 - BG1 scroll offset X
$FF24 - BG1 scroll offset Y
$FF25 - Scroll offset MSB
    (most significant bits)
    used for big cell size only:
    Bit  Purpose
    0    BG0 X+256
    1    BG0 Y+256
    2    BG1 X+256
    3    BG1 Y+256

$FF26 - Raster line
</pre>

<h3 id="Audio-Registers">Audio Registers</h3>

<p>There are registers for 4 voices:</p>
<pre>
$FF40 - Voice 0
$FF4C - Voice 1
$FF58 - Voice 2
$FF64 - Voice 3
</pre>

<p>Each voice occupies 12 bytes:</p>
<pre>
- Frequency low-byte
- Frequency high-byte
- Status:
    Bit  Purpose
    0-3  Volume
    4    Mix to left
    5    Mix to right
    6    Init
    7    Gate
- Peak meter (read only)
- Attributes:
    Bit  Purpose
    0-3  Pulse width
    4-5  Wave:
         0: Sawtooth
         1: Triangle
         2: Pulse
         3: Noise
    6    Timeout enabled
- Length (timeout)
- Envelope byte 1:
    Bit  Purpose
    0-3  Attack
    4-7  Decay
- Envelope byte 2:
    Bit  Purpose
    0-3  Sustain
    4-7  Release
- LFO attributes:
    Bit  Purpose
    0-1  Wave:
         0: Triangle
         1: Sawtooth
         2: Square
         3: Random
    2    Invert
    3    Env mode enabled
    4    Trigger enabled
- LFO settings byte 1:
    Bit  Purpose
    0-3  LFO Rate
    4-7  Frequency amount
- LFO settings byte 2:
    Bit  Purpose
    0-3  Volume amount
    4-7  Pulse width amount
- Reserved
</pre>
<p>Note: The frequency is a 16-bit value: f = hertz * 16</p>


<h3 id="I-O-Registers">I/O Registers</h3>

<pre>
$FF70 - Gamepad 0 status
$FF71 - Gamepad 1 status

Gamepad status:
    Bit  Purpose
    0    Up
    1    Down
    2    Left
    3    Right
    4    Button A
    5    Button B

$FF72 - Last touch X position
$FF73 - Last touch Y position
$FF74 - Last pressed key (ASCII code)
$FF75 - Status:
    Bit  Purpose
    0    Pause button
    1    Touch

$FF76 - Attributes:
    Bit  Purpose
    0-1  Gamepads enabled:
         0: off (touchscreen enabled)
         1: 1 player (touch disabled)
         2: 2 players (touch disabled)
    2    Keyboard enabled
</pre>

</body>
</html>
